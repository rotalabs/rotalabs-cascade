{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"rotalabs-cascade","text":"<p>Domain-agnostic orchestration engine for multi-stage decision routing.</p>"},{"location":"#what-is-rotalabs-cascade","title":"What is rotalabs-cascade?","text":"<p>rotalabs-cascade provides a configuration-driven framework for orchestrating multi-stage decision workflows with sophisticated routing logic. It enables you to define complex processing pipelines declaratively using YAML or JSON, with runtime control over stage execution based on intermediate results.</p> <ul> <li>Configuration-driven orchestration - Define entire pipelines in YAML/JSON without writing orchestration code</li> <li>Dynamic routing - Conditionally enable, disable, or skip stages based on intermediate results</li> <li>Domain-agnostic - Same cascade logic works for finance, healthcare, content moderation, security, and more</li> <li>Production-ready - Includes caching, retries, circuit breakers, metrics, and hot-reload support</li> </ul>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#event-context-pattern","title":"Event + Context Pattern","text":"<p>Structured input model that separates \"what happened\" (the event) from \"the circumstances\" (context). This abstraction allows the same cascade routing logic to work across any domain.</p>"},{"location":"#5-level-cascade-architecture","title":"5-Level Cascade Architecture","text":"<p>Organize processing into levels of increasing cost and sophistication:</p> Level Stage Relative Cost Use Case 1 RULES 1x Simple threshold checks 2 STATISTICAL_ML 5x Feature-based ML models 3 SINGLE_AI 25x Single LLM call 4 POD 100x Multi-agent consensus 5 ADVERSARIAL 500x Adversarial validation"},{"location":"#apls-adaptive-pattern-learning-system","title":"APLS (Adaptive Pattern Learning System)","text":"<p>Learn from execution patterns to optimize cascade routing. APLS identifies costly processing paths and generates rules to move decisions to cheaper stages, reducing compute costs while maintaining accuracy.</p>"},{"location":"#plugin-system","title":"Plugin System","text":"<p>Built-in plugins for cross-cutting concerns:</p> <ul> <li>CachePlugin - Cache stage results with configurable TTL</li> <li>RetryPlugin - Retry with exponential backoff</li> <li>MetricsPlugin - Collect execution metrics</li> <li>CircuitBreakerPlugin - Prevent cascading failures</li> </ul>"},{"location":"#supported-domains","title":"Supported Domains","text":"Domain Use Case Event Example Finance Fraud detection, transaction approval Payments, transfers, withdrawals Healthcare Claims processing, triage Insurance claims, prescriptions Content Moderation, spam detection Posts, comments, uploads Security Access control, threat detection Logins, API calls, data transfers Support Ticket routing, priority escalation Customer tickets, complaints HR Resume screening, application review Job applications, candidates"},{"location":"#package-overview","title":"Package Overview","text":"<pre><code>rotalabs_cascade/\n\u251c\u2500\u2500 core/               # Core engine and configuration\n\u2502   \u251c\u2500\u2500 engine          # CascadeEngine orchestration\n\u2502   \u251c\u2500\u2500 config          # CascadeConfig, StageConfig, RoutingRule\n\u2502   \u251c\u2500\u2500 context         # ExecutionContext, StageResult\n\u2502   \u2514\u2500\u2500 event           # UniversalEvent, EventContext, EventWithContext\n\u251c\u2500\u2500 evaluation/         # Condition evaluation\n\u2502   \u2514\u2500\u2500 evaluator       # ConditionEvaluator\n\u251c\u2500\u2500 optimization/       # Execution optimization\n\u2502   \u2514\u2500\u2500 optimizer       # ExecutionOptimizer\n\u251c\u2500\u2500 plugins/            # Built-in plugins\n\u2502   \u2514\u2500\u2500 builtin         # Cache, Retry, Metrics, CircuitBreaker\n\u2514\u2500\u2500 learning/           # APLS - Adaptive Pattern Learning\n    \u251c\u2500\u2500 pattern_extractor   # Extract patterns from failures\n    \u251c\u2500\u2500 rule_generator      # Generate rules from patterns\n    \u251c\u2500\u2500 cost_analyzer       # Calculate migration ROI\n    \u2514\u2500\u2500 proposal            # Human-in-the-loop workflow\n</code></pre>"},{"location":"#quick-links","title":"Quick Links","text":"<ul> <li>Getting Started - Installation and first steps</li> <li>Event + Context - Understanding the domain-agnostic input model</li> <li>Basic Cascade Tutorial - Build your first cascade</li> <li>APLS Learning Tutorial - Optimize routing with pattern learning</li> <li>API Reference - Detailed API documentation</li> </ul>"},{"location":"event-context/","title":"Event + Context Pattern","text":"<p>The Event + Context pattern is the foundational abstraction that makes rotalabs-cascade domain-agnostic. It cleanly separates what happened (the Event) from the circumstances surrounding it (the Context), enabling the same cascade routing logic to work across finance, healthcare, cybersecurity, content moderation, and any other domain.</p>"},{"location":"event-context/#overview","title":"Overview","text":"<p>Traditional detection systems are tightly coupled to their domain. A fraud detection system speaks in \"transactions\" and \"amounts,\" while a content moderation system speaks in \"posts\" and \"violations.\" This coupling makes it difficult to share infrastructure, patterns, and learnings across domains.</p> <p>The Event + Context pattern solves this by providing universal abstractions:</p> <ul> <li>UniversalEvent: Describes what happened in domain-neutral terms</li> <li>EventContext: Captures the circumstances (who, where, when, history)</li> <li>EventWithContext: Combines both as input to the cascade engine</li> </ul>"},{"location":"event-context/#universalevent-structure","title":"UniversalEvent Structure","text":"<p>The <code>UniversalEvent</code> dataclass represents any action or occurrence that needs to be evaluated by the cascade:</p> <pre><code>from dataclasses import dataclass, field\nfrom datetime import datetime\nfrom typing import Any, Dict, Optional\n\n@dataclass\nclass UniversalEvent:\n    id: str                      # Unique event identifier\n    domain: DomainType           # Domain this event belongs to\n    event_type: str              # Type of event (transaction, post, claim, etc.)\n    timestamp: datetime          # When the event occurred\n    primary_entity: str          # Who initiated (user, customer, patient)\n    secondary_entity: str        # Target/recipient (merchant, provider, system)\n    value: float                 # Numeric value (amount, size, severity 0-1)\n    unit: str                    # Unit of value (USD, bytes, severity_score)\n    domain_data: Dict[str, Any]  # Domain-specific payload\n    correlation_id: Optional[str] = None\n    source_system: Optional[str] = None\n    event_version: str = \"1.0\"\n</code></pre>"},{"location":"event-context/#field-semantics-by-domain","title":"Field Semantics by Domain","text":"Field Finance Content Moderation Cybersecurity Healthcare <code>primary_entity</code> user_id author_id user_id patient_id <code>secondary_entity</code> merchant_id forum/channel resource provider_id <code>value</code> amount content_length risk_score claim_amount <code>unit</code> USD/EUR characters risk_score USD <code>domain_data</code> card_type, mcc content, has_media action, ip diagnosis, codes"},{"location":"event-context/#supported-domains","title":"Supported Domains","text":"<p>The <code>DomainType</code> enum defines the supported domains:</p> <pre><code>class DomainType(Enum):\n    FINANCE = \"FINANCE\"\n    HEALTHCARE = \"HEALTHCARE\"\n    SUPPLY_CHAIN = \"SUPPLY_CHAIN\"\n    CYBERSECURITY = \"CYBERSECURITY\"\n    CONTENT_MODERATION = \"CONTENT_MODERATION\"\n    CUSTOMER_SUPPORT = \"CUSTOMER_SUPPORT\"\n    INSURANCE = \"INSURANCE\"\n    RETAIL = \"RETAIL\"\n    HR_RECRUITING = \"HR_RECRUITING\"\n    GENERIC = \"GENERIC\"\n</code></pre>"},{"location":"event-context/#eventcontext-structure","title":"EventContext Structure","text":"<p>The <code>EventContext</code> dataclass captures contextual information surrounding an event:</p> <pre><code>@dataclass\nclass EventContext:\n    session: SessionContext           # Session-related info\n    device: DeviceContext             # Device-related info\n    location: LocationContext         # Location-related info\n    historical: HistoricalContext     # Historical behavior\n    entity: EntityContext             # Entity information\n    domain_context: Dict[str, Any]    # Domain-specific extension\n    context_timestamp: datetime       # When context was captured\n    context_version: str = \"1.0\"\n</code></pre>"},{"location":"event-context/#sessioncontext","title":"SessionContext","text":"<p>Captures session and authentication information:</p> <pre><code>@dataclass\nclass SessionContext:\n    ip_address: Optional[str] = None\n    user_agent: Optional[str] = None\n    session_id: Optional[str] = None\n    login_timestamp: Optional[datetime] = None\n    session_duration_minutes: Optional[int] = None\n    previous_session_count: Optional[int] = None\n    is_authenticated: Optional[bool] = None\n    auth_method: Optional[str] = None  # password, oauth, sso, mfa\n</code></pre>"},{"location":"event-context/#devicecontext","title":"DeviceContext","text":"<p>Captures device fingerprint and characteristics:</p> <pre><code>@dataclass\nclass DeviceContext:\n    device_id: Optional[str] = None\n    device_type: Optional[str] = None  # mobile, desktop, tablet, iot\n    device_info: Optional[str] = None\n    operating_system: Optional[str] = None\n    browser: Optional[str] = None\n    app_version: Optional[str] = None\n    is_trusted_device: Optional[bool] = None\n    device_fingerprint: Optional[str] = None\n</code></pre>"},{"location":"event-context/#locationcontext","title":"LocationContext","text":"<p>Captures geographic and network location:</p> <pre><code>@dataclass\nclass LocationContext:\n    current_location: Optional[str] = None\n    registered_location: Optional[str] = None\n    coordinates: Optional[Dict[str, float]] = None  # {lat, lng}\n    country: Optional[str] = None\n    region: Optional[str] = None\n    city: Optional[str] = None\n    timezone: Optional[str] = None\n    vpn_detected: Optional[bool] = None\n    proxy_detected: Optional[bool] = None\n    location_accuracy: Optional[str] = None  # precise, city, region, country\n</code></pre>"},{"location":"event-context/#historicalcontext","title":"HistoricalContext","text":"<p>Captures behavioral history and trust signals:</p> <pre><code>@dataclass\nclass HistoricalContext:\n    account_age_days: Optional[int] = None\n    previous_events_count: Optional[int] = None\n    average_event_value: Optional[float] = None\n    max_event_value: Optional[float] = None\n    typical_event_times: Optional[List[str]] = None  # [\"09:00-17:00\"]\n    typical_locations: Optional[List[str]] = None\n    last_event_timestamp: Optional[datetime] = None\n    event_frequency_per_day: Optional[float] = None\n    trust_score: Optional[float] = None  # 0-1 historical trust\n    risk_flags: Optional[List[str]] = None\n</code></pre>"},{"location":"event-context/#entitycontext","title":"EntityContext","text":"<p>Captures information about the entities involved:</p> <pre><code>@dataclass\nclass EntityContext:\n    primary_entity_id: Optional[str] = None\n    primary_entity_type: Optional[str] = None  # user, customer, patient\n    primary_entity_verified: Optional[bool] = None\n    secondary_entity_id: Optional[str] = None\n    secondary_entity_type: Optional[str] = None  # merchant, provider, vendor\n    secondary_entity_trust: Optional[float] = None\n    relationship_age_days: Optional[int] = None\n</code></pre>"},{"location":"event-context/#eventwithcontext","title":"EventWithContext","text":"<p>The <code>EventWithContext</code> dataclass combines both structures and serves as the primary input to the cascade engine:</p> <pre><code>@dataclass\nclass EventWithContext:\n    event: UniversalEvent\n    context: EventContext\n</code></pre>"},{"location":"event-context/#example-usage","title":"Example Usage","text":"<pre><code>from rotalabs_cascade import (\n    UniversalEvent, EventContext, EventWithContext,\n    DomainType, SessionContext, HistoricalContext, CascadeEngine\n)\nfrom datetime import datetime\n\n# Create the event\nevent = UniversalEvent(\n    id=\"evt_abc123\",\n    domain=DomainType.CONTENT_MODERATION,\n    event_type=\"post\",\n    timestamp=datetime.now(),\n    primary_entity=\"user_456\",\n    secondary_entity=\"forum_general\",\n    value=0.0,\n    unit=\"post\",\n    domain_data={\n        \"content\": \"Check out this amazing deal!\",\n        \"has_media\": False,\n        \"mentions\": [\"@everyone\"]\n    }\n)\n\n# Create the context\ncontext = EventContext(\n    session=SessionContext(\n        ip_address=\"192.168.1.100\",\n        is_authenticated=True\n    ),\n    historical=HistoricalContext(\n        account_age_days=30,\n        previous_events_count=100,\n        trust_score=0.85\n    )\n)\n\n# Combine into EventWithContext\nevent_with_context = EventWithContext(event=event, context=context)\n\n# Execute through cascade\nresult = await engine.execute(event_with_context)\n</code></pre>"},{"location":"event-context/#domain-examples","title":"Domain Examples","text":""},{"location":"event-context/#finance-transaction-fraud-detection","title":"Finance: Transaction Fraud Detection","text":"<pre><code>from rotalabs_cascade import create_finance_event, EventContext, EventWithContext\n\n# Use the factory function for finance events\nevent = create_finance_event(\n    transaction_id=\"txn_789\",\n    user_id=\"cust_123\",\n    merchant_id=\"merch_456\",\n    amount=2500.00,\n    currency=\"USD\",\n    transaction_type=\"purchase\",\n    # Additional domain data\n    card_type=\"credit\",\n    mcc_code=\"5411\",  # Grocery stores\n    is_card_present=False\n)\n\ncontext = EventContext(\n    session=SessionContext(\n        ip_address=\"203.0.113.50\",\n        auth_method=\"mfa\"\n    ),\n    device=DeviceContext(\n        device_type=\"mobile\",\n        is_trusted_device=True\n    ),\n    location=LocationContext(\n        country=\"US\",\n        region=\"CA\",\n        vpn_detected=False\n    ),\n    historical=HistoricalContext(\n        account_age_days=730,\n        average_event_value=150.00,\n        max_event_value=500.00,\n        trust_score=0.92\n    )\n)\n\nevent_with_context = EventWithContext(event=event, context=context)\n</code></pre>"},{"location":"event-context/#content-moderation-post-review","title":"Content Moderation: Post Review","text":"<pre><code>from rotalabs_cascade import create_content_event, EventContext, EventWithContext\n\n# Use the factory function for content events\nevent = create_content_event(\n    content_id=\"post_abc123\",\n    user_id=\"author_456\",\n    target=\"community_gaming\",\n    content_type=\"post\",\n    content=\"Join my Discord for free giveaways! Click here: bit.ly/xxx\",\n    # Additional domain data\n    has_links=True,\n    link_count=1,\n    mentions_count=0,\n    hashtags=[\"giveaway\", \"free\"]\n)\n\ncontext = EventContext(\n    session=SessionContext(\n        ip_address=\"198.51.100.25\",\n        user_agent=\"Mozilla/5.0...\"\n    ),\n    historical=HistoricalContext(\n        account_age_days=3,\n        previous_events_count=5,\n        trust_score=0.2,\n        risk_flags=[\"new_account\", \"rapid_posting\"]\n    )\n)\n\nevent_with_context = EventWithContext(event=event, context=context)\n</code></pre>"},{"location":"event-context/#cybersecurity-access-attempt","title":"Cybersecurity: Access Attempt","text":"<pre><code>from rotalabs_cascade import create_security_event, EventContext, EventWithContext\n\n# Use the factory function for security events\nevent = create_security_event(\n    event_id=\"sec_xyz789\",\n    user_id=\"employee_123\",\n    resource=\"database_prod\",\n    action=\"access_attempt\",\n    risk_score=0.7,\n    # Additional domain data\n    requested_permission=\"read\",\n    time_of_day=\"02:30\",\n    is_after_hours=True\n)\n\ncontext = EventContext(\n    session=SessionContext(\n        ip_address=\"10.0.0.50\",\n        auth_method=\"sso\"\n    ),\n    device=DeviceContext(\n        device_type=\"desktop\",\n        is_trusted_device=False,\n        device_fingerprint=\"unknown\"\n    ),\n    location=LocationContext(\n        country=\"CN\",\n        vpn_detected=True\n    ),\n    historical=HistoricalContext(\n        typical_event_times=[\"09:00-17:00\"],\n        typical_locations=[\"US\"],\n        trust_score=0.6\n    )\n)\n\nevent_with_context = EventWithContext(event=event, context=context)\n</code></pre>"},{"location":"event-context/#healthcare-claim-review","title":"Healthcare: Claim Review","text":"<pre><code>from rotalabs_cascade import UniversalEvent, DomainType, EventContext, EventWithContext\nfrom datetime import datetime\n\nevent = UniversalEvent(\n    id=\"claim_12345\",\n    domain=DomainType.HEALTHCARE,\n    event_type=\"claim\",\n    timestamp=datetime.now(),\n    primary_entity=\"patient_789\",\n    secondary_entity=\"provider_456\",\n    value=15000.00,\n    unit=\"USD\",\n    domain_data={\n        \"diagnosis_codes\": [\"J18.9\", \"R05\"],\n        \"procedure_codes\": [\"99213\", \"94640\"],\n        \"service_date\": \"2024-01-15\",\n        \"facility_type\": \"outpatient\"\n    }\n)\n\ncontext = EventContext(\n    entity=EntityContext(\n        primary_entity_type=\"patient\",\n        secondary_entity_type=\"provider\",\n        secondary_entity_trust=0.95,\n        relationship_age_days=1825  # 5 years\n    ),\n    historical=HistoricalContext(\n        average_event_value=500.00,\n        max_event_value=3000.00,\n        previous_events_count=45\n    ),\n    domain_context={\n        \"provider_specialty\": \"pulmonology\",\n        \"patient_insurance_type\": \"PPO\",\n        \"pre_authorization\": True\n    }\n)\n\nevent_with_context = EventWithContext(event=event, context=context)\n</code></pre>"},{"location":"event-context/#why-domain-agnostic","title":"Why Domain-Agnostic?","text":"<p>The Event + Context pattern enables several powerful capabilities:</p>"},{"location":"event-context/#1-shared-infrastructure","title":"1. Shared Infrastructure","text":"<p>The same cascade engine, routing rules, and execution infrastructure work across all domains. You build it once and apply it everywhere.</p>"},{"location":"event-context/#2-pattern-transfer","title":"2. Pattern Transfer","text":"<p>Patterns learned in one domain can inform detection in another. A velocity check pattern in fraud detection (too many transactions too fast) maps naturally to spam detection (too many posts too fast).</p>"},{"location":"event-context/#3-unified-observability","title":"3. Unified Observability","text":"<p>Metrics, logging, and monitoring use the same schema regardless of domain. A single dashboard can show detection rates, stage latencies, and cost metrics across your entire organization.</p>"},{"location":"event-context/#4-consistent-developer-experience","title":"4. Consistent Developer Experience","text":"<p>Teams working on different domains use the same APIs, configuration format, and mental model. Knowledge transfers easily between teams.</p>"},{"location":"event-context/#5-flexible-extension","title":"5. Flexible Extension","text":"<p>The <code>domain_data</code> field in <code>UniversalEvent</code> and <code>domain_context</code> field in <code>EventContext</code> provide escape hatches for domain-specific data without breaking the universal schema.</p>"},{"location":"event-context/#converting-from-flat-dictionaries","title":"Converting from Flat Dictionaries","text":"<p>For backward compatibility, <code>EventWithContext</code> can be converted to a flat dictionary:</p> <pre><code>event_with_context = EventWithContext(event=event, context=context)\n\n# Get flat dictionary for ExecutionContext\nflat_dict = event_with_context.to_flat_dict()\n\n# Contains both nested structure and top-level shortcuts:\n# {\n#     \"event\": {...},\n#     \"context\": {...},\n#     \"event_id\": \"evt_abc123\",\n#     \"domain\": \"CONTENT_MODERATION\",\n#     \"value\": 0.0,\n#     \"ip_address\": \"192.168.1.100\",\n#     \"account_age_days\": 30,\n#     ...\n# }\n</code></pre>"},{"location":"event-context/#parsing-from-api-requests","title":"Parsing from API Requests","text":"<p>When receiving events from external systems, use <code>from_dict</code>:</p> <pre><code># Incoming API request\nrequest_data = {\n    \"event\": {\n        \"id\": \"evt_123\",\n        \"domain\": \"FINANCE\",\n        \"event_type\": \"transaction\",\n        \"timestamp\": \"2024-01-15T10:30:00\",\n        \"primary_entity\": \"user_456\",\n        \"secondary_entity\": \"merchant_789\",\n        \"value\": 100.00,\n        \"unit\": \"USD\",\n        \"domain_data\": {\"card_type\": \"debit\"}\n    },\n    \"context\": {\n        \"session\": {\"ip_address\": \"192.168.1.1\"},\n        \"historical\": {\"account_age_days\": 365}\n    }\n}\n\n# Parse into strongly-typed objects\nevent_with_context = EventWithContext.from_dict(request_data)\n</code></pre>"},{"location":"event-context/#summary","title":"Summary","text":"<p>The Event + Context pattern is the foundation that makes rotalabs-cascade truly domain-agnostic:</p> <ul> <li>UniversalEvent captures what happened using generic fields that map to any domain</li> <li>EventContext captures the circumstances through structured sub-contexts</li> <li>EventWithContext combines both as the primary input to cascade processing</li> <li>Factory functions (<code>create_finance_event</code>, <code>create_content_event</code>, etc.) simplify event creation</li> <li>The pattern enables shared infrastructure, pattern transfer, and consistent developer experience</li> </ul>"},{"location":"getting-started/","title":"Getting Started","text":""},{"location":"getting-started/#installation","title":"Installation","text":""},{"location":"getting-started/#basic-installation","title":"Basic Installation","text":"<pre><code>pip install rotalabs-cascade\n</code></pre>"},{"location":"getting-started/#with-optional-dependencies","title":"With Optional Dependencies","text":"<pre><code># Structured logging with structlog\npip install rotalabs-cascade[structlog]\n\n# OpenTelemetry observability\npip install rotalabs-cascade[observability]\n\n# Development tools (pytest, black, ruff)\npip install rotalabs-cascade[dev]\n\n# All optional dependencies\npip install rotalabs-cascade[all]\n</code></pre>"},{"location":"getting-started/#core-dependencies","title":"Core Dependencies","text":"<p>The base package requires:</p> <ul> <li><code>pyyaml&gt;=6.0</code></li> <li><code>python&gt;=3.9</code></li> </ul>"},{"location":"getting-started/#basic-usage","title":"Basic Usage","text":""},{"location":"getting-started/#1-define-your-cascade-configuration","title":"1. Define Your Cascade Configuration","text":"<p>Create a YAML configuration file defining your stages and routing rules:</p> <pre><code># cascade_config.yaml\nname: trust_scoring_cascade\nversion: \"1.0\"\n\nstages:\n  FAST_CHECK:\n    name: FAST_CHECK\n    enabled: true\n    timeout_ms: 100\n    routing_rules:\n      - name: low_confidence_escalate\n        type: routing\n        priority: 100\n        condition:\n          field: stages.FAST_CHECK.confidence\n          operator: \"&lt;\"\n          value: 0.8\n        action:\n          type: enable_stages\n          stages: [\"MEDIUM_CHECK\"]\n\n      - name: high_confidence_terminate\n        type: routing\n        priority: 90\n        condition:\n          field: stages.FAST_CHECK.confidence\n          operator: \"&gt;=\"\n          value: 0.95\n        action:\n          type: terminate\n\n  MEDIUM_CHECK:\n    name: MEDIUM_CHECK\n    enabled: false  # Only enabled if FAST_CHECK triggers it\n    timeout_ms: 500\n    depends_on: [\"FAST_CHECK\"]\n    routing_rules:\n      - name: still_uncertain\n        type: routing\n        priority: 100\n        condition:\n          field: stages.MEDIUM_CHECK.confidence\n          operator: \"&lt;\"\n          value: 0.9\n        action:\n          type: enable_stages\n          stages: [\"EXPENSIVE_CHECK\"]\n\n  EXPENSIVE_CHECK:\n    name: EXPENSIVE_CHECK\n    enabled: false\n    timeout_ms: 2000\n    depends_on: [\"MEDIUM_CHECK\"]\n\nexecution_order:\n  - FAST_CHECK\n  - MEDIUM_CHECK\n  - EXPENSIVE_CHECK\n\nglobal_timeout_ms: 5000\nmax_parallel_stages: 3\n</code></pre>"},{"location":"getting-started/#2-implement-stage-handlers","title":"2. Implement Stage Handlers","text":"<p>Create async handler functions for each stage:</p> <pre><code>import asyncio\nfrom rotalabs_cascade import CascadeConfig, CascadeEngine, ExecutionContext\n\n# Implement your stage handlers\nasync def fast_check_handler(context: ExecutionContext) -&gt; dict:\n    \"\"\"Fast heuristic check.\"\"\"\n    user_id = context.get(\"user_id\")\n\n    # Quick validation logic\n    confidence = 0.75 if user_id.startswith(\"trusted_\") else 0.4\n\n    return {\n        \"result\": \"pass\" if confidence &gt; 0.5 else \"review\",\n        \"confidence\": confidence,\n        \"data\": {\"method\": \"heuristic\", \"checks\": [\"basic_validation\"]}\n    }\n\nasync def medium_check_handler(context: ExecutionContext) -&gt; dict:\n    \"\"\"Medium complexity ML model check.\"\"\"\n    # Simulate ML model inference\n    await asyncio.sleep(0.3)\n\n    return {\n        \"result\": \"pass\",\n        \"confidence\": 0.85,\n        \"data\": {\"method\": \"ml_model\", \"model\": \"trust_v2\"}\n    }\n\nasync def expensive_check_handler(context: ExecutionContext) -&gt; dict:\n    \"\"\"Expensive deep analysis.\"\"\"\n    # Simulate expensive computation\n    await asyncio.sleep(1.5)\n\n    return {\n        \"result\": \"pass\",\n        \"confidence\": 0.99,\n        \"data\": {\"method\": \"deep_analysis\", \"checks_run\": 47}\n    }\n</code></pre>"},{"location":"getting-started/#3-execute-the-cascade","title":"3. Execute the Cascade","text":"<p>Load configuration, register handlers, and execute:</p> <pre><code>async def main():\n    # Load configuration\n    config = CascadeConfig.from_file(\"cascade_config.yaml\")\n\n    # Create engine\n    engine = CascadeEngine(config)\n\n    # Register stage handlers\n    engine.register_stage(\"FAST_CHECK\", fast_check_handler)\n    engine.register_stage(\"MEDIUM_CHECK\", medium_check_handler)\n    engine.register_stage(\"EXPENSIVE_CHECK\", expensive_check_handler)\n\n    # Execute cascade with input data\n    result = await engine.execute({\n        \"user_id\": \"user_12345\",\n        \"action\": \"withdraw\",\n        \"amount\": 10000\n    })\n\n    # Inspect results\n    print(f\"Success: {result['success']}\")\n    print(f\"Execution time: {result['execution_time_ms']:.2f}ms\")\n    print(f\"Stages executed: {result['stages_executed']}\")\n\n    for stage_name, stage_result in result[\"stage_results\"].items():\n        print(f\"\\n{stage_name}:\")\n        print(f\"  Result: {stage_result['result']}\")\n        print(f\"  Confidence: {stage_result.get('confidence', 'N/A')}\")\n        print(f\"  Time: {stage_result['time_ms']:.2f}ms\")\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <p>Output: <pre><code>Success: True\nExecution time: 345.67ms\nStages executed: 2\n\nFAST_CHECK:\n  Result: review\n  Confidence: 0.4\n  Time: 2.34ms\n\nMEDIUM_CHECK:\n  Result: pass\n  Confidence: 0.85\n  Time: 312.45ms\n</code></pre></p>"},{"location":"getting-started/#using-the-event-context-pattern","title":"Using the Event + Context Pattern","text":"<p>For domain-agnostic processing, use the structured Event + Context pattern:</p> <pre><code>from datetime import datetime\nfrom rotalabs_cascade import (\n    CascadeEngine,\n    CascadeConfig,\n    UniversalEvent,\n    EventContext,\n    EventWithContext,\n    DomainType,\n    SessionContext,\n    DeviceContext,\n    LocationContext,\n    HistoricalContext,\n)\n\n# Create a universal event (works for any domain)\nevent = UniversalEvent(\n    id=\"txn_123\",\n    domain=DomainType.FINANCE,\n    event_type=\"transaction\",\n    timestamp=datetime.now(),\n    primary_entity=\"user_alice\",      # who initiated\n    secondary_entity=\"merchant_xyz\",  # target/recipient\n    value=250.00,                     # amount\n    unit=\"USD\",\n    domain_data={\"card_type\": \"credit\", \"merchant_category\": \"retail\"}\n)\n\n# Create structured context\ncontext = EventContext(\n    session=SessionContext(\n        ip_address=\"192.168.1.100\",\n        is_authenticated=True,\n        auth_method=\"mfa\"\n    ),\n    device=DeviceContext(\n        device_type=\"mobile\",\n        is_trusted_device=True\n    ),\n    location=LocationContext(\n        country=\"US\",\n        city=\"San Francisco\",\n        vpn_detected=False\n    ),\n    historical=HistoricalContext(\n        account_age_days=730,\n        previous_events_count=500,\n        trust_score=0.92\n    )\n)\n\n# Combine event and context\nevent_with_context = EventWithContext(event=event, context=context)\n\n# Execute cascade - same logic works for ANY domain\nresult = await engine.execute(event_with_context.to_flat_dict())\n</code></pre>"},{"location":"getting-started/#running-the-cascade","title":"Running the Cascade","text":""},{"location":"getting-started/#from-a-script","title":"From a Script","text":"<pre><code>import asyncio\nfrom rotalabs_cascade import CascadeConfig, CascadeEngine\n\nasync def run():\n    config = CascadeConfig.from_file(\"cascade_config.yaml\")\n    engine = CascadeEngine(config)\n\n    # Register handlers...\n\n    result = await engine.execute({\"user_id\": \"test_user\"})\n    return result\n\nresult = asyncio.run(run())\n</code></pre>"},{"location":"getting-started/#in-an-async-web-framework","title":"In an Async Web Framework","text":"<pre><code>from fastapi import FastAPI\nfrom rotalabs_cascade import CascadeConfig, CascadeEngine\n\napp = FastAPI()\n\n# Initialize engine at startup\nconfig = CascadeConfig.from_file(\"cascade_config.yaml\")\nengine = CascadeEngine(config)\n# Register handlers...\n\n@app.post(\"/evaluate\")\nasync def evaluate(data: dict):\n    result = await engine.execute(data)\n    return result\n</code></pre>"},{"location":"getting-started/#next-steps","title":"Next Steps","text":"<ul> <li>Read Event + Context to understand the domain-agnostic input model</li> <li>Follow Basic Cascade Tutorial for a detailed walkthrough</li> <li>Learn about APLS Learning for cost optimization</li> <li>See API Reference for full documentation</li> </ul>"},{"location":"api/core/","title":"Core Module","text":"<p>The core module provides the foundational classes for cascade orchestration, including the execution engine, configuration schema, and execution context management.</p>"},{"location":"api/core/#cascadeengine","title":"CascadeEngine","text":"<p>Main orchestration engine for cascade execution.</p> <p>The engine manages stage registration, execution planning, and dynamic routing based on configuration and runtime conditions.</p> <p>Uses slots for memory efficiency.</p> <p>Attributes:</p> Name Type Description <code>config</code> <p>Cascade configuration.</p> <code>_handlers</code> <code>Dict[str, Callable]</code> <p>Registered stage handlers.</p> <code>_result_cache</code> <code>Dict[str, Tuple[Any, float]]</code> <p>Cache for stage results.</p> <code>_plan_cache</code> <code>Dict[str, List[str]]</code> <p>Cache for execution plans.</p> <code>_statistics</code> <p>Execution statistics.</p>"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.__init__","title":"<code>__init__(config: CascadeConfig)</code>","text":"<p>Initialize cascade engine.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CascadeConfig</code> <p>Cascade configuration.</p> required"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.register_stage","title":"<code>register_stage(name: str, handler: Callable) -&gt; None</code>","text":"<p>Register a stage handler.</p> <p>Wraps handler with monitoring and error handling.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Stage name matching configuration.</p> required <code>handler</code> <code>Callable</code> <p>Async callable that processes stage execution.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If stage name not in configuration.</p>"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.execute","title":"<code>execute(data: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Execute cascade with input data.</p> <p>Main entry point for cascade execution. Creates execution context, generates or retrieves cached execution plan, and executes stages with dynamic routing.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Input data dictionary.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Execution result dictionary.</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If global timeout exceeded.</p> <code>RuntimeError</code> <p>If execution fails critically.</p>"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.get_statistics","title":"<code>get_statistics() -&gt; Dict[str, Any]</code>","text":"<p>Get execution statistics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary of statistics per stage.</p>"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.clear_cache","title":"<code>clear_cache() -&gt; None</code>","text":"<p>Clear all caches (result and plan caches).</p>"},{"location":"api/core/#rotalabs_cascade.core.engine.CascadeEngine.update_config","title":"<code>update_config(config: CascadeConfig) -&gt; None</code>","text":"<p>Hot-reload configuration.</p> <p>Updates engine configuration and recompiles routing rules without losing registered handlers or statistics.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>CascadeConfig</code> <p>New cascade configuration.</p> required"},{"location":"api/core/#cascadeconfig","title":"CascadeConfig","text":"<p>Complete cascade orchestration configuration.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Cascade configuration name.</p> <code>version</code> <code>str</code> <p>Configuration version.</p> <code>stages</code> <code>Dict[str, StageConfig]</code> <p>Dictionary of stage configurations keyed by name.</p> <code>execution_order</code> <code>List[str]</code> <p>Initial execution order (stage names).</p> <code>global_timeout_ms</code> <code>int</code> <p>Global execution timeout in milliseconds.</p> <code>max_parallel_stages</code> <code>int</code> <p>Maximum stages to execute in parallel.</p> <code>global_termination_conditions</code> <code>List[Condition]</code> <p>Conditions that terminate entire cascade.</p> <code>enable_caching</code> <code>bool</code> <p>Whether to enable result caching.</p> <code>cache_key_fields</code> <code>List[str]</code> <p>Fields to include in cache key.</p> <code>domain_config</code> <code>Dict[str, Any]</code> <p>Domain-specific configuration.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.CascadeConfig.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; CascadeConfig</code>  <code>classmethod</code>","text":"<p>Create cascade config from dictionary.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.CascadeConfig.from_file","title":"<code>from_file(path: Union[str, Path]) -&gt; CascadeConfig</code>  <code>classmethod</code>","text":"<p>Load cascade config from JSON or YAML file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Union[str, Path]</code> <p>Path to configuration file (.json or .yaml/.yml).</p> required <p>Returns:</p> Type Description <code>CascadeConfig</code> <p>Loaded cascade configuration.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file format is unsupported.</p> <code>ImportError</code> <p>If YAML file provided but PyYAML not installed.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.CascadeConfig.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert cascade config to dictionary.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.CascadeConfig.to_json","title":"<code>to_json(indent: int = 2) -&gt; str</code>","text":"<p>Convert cascade config to JSON string.</p> <p>Parameters:</p> Name Type Description Default <code>indent</code> <code>int</code> <p>JSON indentation level.</p> <code>2</code> <p>Returns:</p> Type Description <code>str</code> <p>JSON representation of config.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.CascadeConfig.to_yaml","title":"<code>to_yaml() -&gt; str</code>","text":"<p>Convert cascade config to YAML string.</p> <p>Returns:</p> Type Description <code>str</code> <p>YAML representation of config.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyYAML is not installed.</p>"},{"location":"api/core/#stageconfig","title":"StageConfig","text":"<p>Configuration for a single execution stage.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique stage identifier.</p> <code>enabled</code> <code>bool</code> <p>Whether stage is initially enabled.</p> <code>handler_type</code> <code>Optional[str]</code> <p>Type of handler (determines handler resolution).</p> <code>timeout_ms</code> <code>int</code> <p>Execution timeout in milliseconds.</p> <code>max_retries</code> <code>int</code> <p>Maximum retry attempts on failure.</p> <code>retry_delay_ms</code> <code>int</code> <p>Delay between retries in milliseconds.</p> <code>can_run_parallel</code> <code>bool</code> <p>Whether stage can execute in parallel with others.</p> <code>parallel_group</code> <code>Optional[str]</code> <p>Group identifier for parallel execution.</p> <code>depends_on</code> <code>List[str]</code> <p>List of stage names this stage depends on.</p> <code>routing_rules</code> <code>List[RoutingRule]</code> <p>Stage-specific routing rules.</p> <code>cache_enabled</code> <code>bool</code> <p>Whether to cache stage results.</p> <code>cache_ttl_seconds</code> <code>int</code> <p>Cache TTL in seconds.</p> <code>custom_properties</code> <code>Dict[str, Any]</code> <p>Domain-specific configuration properties.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.StageConfig.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; StageConfig</code>  <code>classmethod</code>","text":"<p>Create stage config from dictionary.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.StageConfig.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert stage config to dictionary.</p>"},{"location":"api/core/#routingrule","title":"RoutingRule","text":"<p>Defines a routing rule for stage execution control.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Unique rule identifier.</p> <code>type</code> <code>str</code> <p>Rule type (precondition, routing, postcondition).</p> <code>condition</code> <code>Condition</code> <p>Condition to evaluate.</p> <code>action</code> <code>RoutingAction</code> <p>Action to take when condition matches.</p> <code>priority</code> <code>int</code> <p>Rule priority (higher values execute first).</p>"},{"location":"api/core/#rotalabs_cascade.core.config.RoutingRule.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; RoutingRule</code>  <code>classmethod</code>","text":"<p>Create rule from dictionary.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.RoutingRule.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert rule to dictionary.</p>"},{"location":"api/core/#condition","title":"Condition","text":"<p>Represents a condition for routing decisions.</p> <p>Conditions can be simple (field-based) or composite (nested conditions).</p> <p>Attributes:</p> Name Type Description <code>field</code> <code>Optional[str]</code> <p>Field path to evaluate (dot notation supported).</p> <code>operator</code> <code>Optional[Union[str, ConditionOperator]]</code> <p>Condition operator to apply.</p> <code>value</code> <code>Optional[Any]</code> <p>Expected value for comparison.</p> <code>conditions</code> <code>Optional[List[Condition]]</code> <p>Nested conditions for logical operators (AND, OR, NOT).</p>"},{"location":"api/core/#rotalabs_cascade.core.config.Condition.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; Condition</code>  <code>classmethod</code>","text":"<p>Create condition from dictionary.</p>"},{"location":"api/core/#rotalabs_cascade.core.config.Condition.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert condition to dictionary.</p>"},{"location":"api/core/#conditionoperator","title":"ConditionOperator","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Operators for condition evaluation.</p>"},{"location":"api/core/#executioncontext","title":"ExecutionContext","text":"<p>Execution context for cascade orchestration.</p> <p>Manages state, results, and metadata throughout cascade execution. Uses slots for memory efficiency and zero-copy reference to input data.</p> <p>Attributes:</p> Name Type Description <code>_data</code> <p>Reference to input data (zero-copy).</p> <code>_stage_results</code> <code>List[StageResult]</code> <p>List of stage execution results.</p> <code>_errors</code> <code>List[str]</code> <p>List of error messages.</p> <code>_metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata dictionary.</p> <code>_start_time</code> <p>Execution start timestamp.</p> <code>_termination_flag</code> <p>Whether execution should terminate.</p> <code>_next_stage</code> <code>Optional[str]</code> <p>Next stage to execute (for skip_to actions).</p> <code>_enabled_stages</code> <code>set</code> <p>Set of dynamically enabled stage names.</p> <code>_disabled_stages</code> <code>set</code> <p>Set of dynamically disabled stage names.</p> <code>_cache</code> <code>Dict[str, Any]</code> <p>Cache for computed values (dot notation lookups).</p> <code>_execution_order</code> <code>List[str]</code> <p>Planned execution order.</p> <code>_timeline</code> <code>List[Dict[str, Any]]</code> <p>Timeline of execution events.</p> <code>_routing_decisions</code> <code>List[Dict[str, Any]]</code> <p>List of routing decisions made.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.data","title":"<code>data: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get reference to input data.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.elapsed_ms","title":"<code>elapsed_ms: float</code>  <code>property</code>","text":"<p>Get elapsed execution time in milliseconds.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.should_terminate","title":"<code>should_terminate: bool</code>  <code>property</code>","text":"<p>Check if execution should terminate.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.__init__","title":"<code>__init__(data: Union[Dict[str, Any], EventWithContext])</code>","text":"<p>Initialize execution context.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Union[Dict[str, Any], EventWithContext]</code> <p>Input data - either a dictionary or EventWithContext object.   If EventWithContext, it will be converted to flat dict for access.</p> required <p>Examples:</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.__init__--flat-dictionary-backward-compatible","title":"Flat dictionary (backward compatible)","text":"<p>ctx = ExecutionContext({\"user_id\": \"123\", \"amount\": 100})</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.__init__--eventwithcontext-domain-agnostic","title":"EventWithContext (domain-agnostic)","text":"<p>ctx = ExecutionContext(EventWithContext(event=..., context=...))</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.get","title":"<code>get(path: str, default: Any = None) -&gt; Any</code>","text":"<p>Get value from data or stage results using dot notation with caching.</p> <p>Supports paths like: - \"user.profile.age\" - looks up in input data - \"stages.FAST_CHECK.confidence\" - looks up in stage results</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Dot-separated path (e.g., \"user.profile.age\").</p> required <code>default</code> <code>Any</code> <p>Default value if path not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Value at path or default.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; ctx.get(\"user.name\")\n'John'\n&gt;&gt;&gt; ctx.get(\"stages.FAST_CHECK.confidence\")\n0.85\n</code></pre>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.set","title":"<code>set(path: str, value: Any) -&gt; None</code>","text":"<p>Set value in data using dot notation.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str</code> <p>Dot-separated path (e.g., \"user.profile.age\").</p> required <code>value</code> <code>Any</code> <p>Value to set.</p> required <p>Examples:</p> <pre><code>&gt;&gt;&gt; ctx.set(\"user.name\", \"Jane\")\n&gt;&gt;&gt; ctx.set(\"user.settings.theme\", \"dark\")\n</code></pre>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.add_stage_result","title":"<code>add_stage_result(result: StageResult) -&gt; None</code>","text":"<p>Add stage execution result.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>StageResult</code> <p>Stage result to add.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.add_stage_error","title":"<code>add_stage_error(stage_name: str, error: str) -&gt; None</code>","text":"<p>Add stage execution error.</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage that failed.</p> required <code>error</code> <code>str</code> <p>Error message.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.get_stage_result","title":"<code>get_stage_result(stage_name: str) -&gt; Optional[StageResult]</code>","text":"<p>Get result for a specific stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage.</p> required <p>Returns:</p> Type Description <code>Optional[StageResult]</code> <p>Stage result if found, None otherwise.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.set_termination_flag","title":"<code>set_termination_flag(reason: Optional[str] = None) -&gt; None</code>","text":"<p>Set termination flag to stop execution.</p> <p>Parameters:</p> Name Type Description Default <code>reason</code> <code>Optional[str]</code> <p>Optional reason for termination.</p> <code>None</code>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.set_next_stage","title":"<code>set_next_stage(stage_name: str) -&gt; None</code>","text":"<p>Set next stage to execute (skip_to action).</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage to skip to.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.get_next_stage","title":"<code>get_next_stage() -&gt; Optional[str]</code>","text":"<p>Get and clear next stage override.</p> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>Next stage name if set, None otherwise.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.enable_stage","title":"<code>enable_stage(stage_name: str) -&gt; None</code>","text":"<p>Dynamically enable a stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage to enable.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.disable_stage","title":"<code>disable_stage(stage_name: str) -&gt; None</code>","text":"<p>Dynamically disable a stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage to disable.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.is_stage_enabled","title":"<code>is_stage_enabled(stage_name: str, default: bool = True) -&gt; bool</code>","text":"<p>Check if a stage is enabled.</p> <p>Parameters:</p> Name Type Description Default <code>stage_name</code> <code>str</code> <p>Name of the stage.</p> required <code>default</code> <code>bool</code> <p>Default value if not explicitly set.</p> <code>True</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if stage is enabled, False otherwise.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.set_metadata","title":"<code>set_metadata(key: str, value: Any) -&gt; None</code>","text":"<p>Set metadata value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Metadata key.</p> required <code>value</code> <code>Any</code> <p>Metadata value.</p> required"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.get_metadata","title":"<code>get_metadata(key: str, default: Any = None) -&gt; Any</code>","text":"<p>Get metadata value.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Metadata key.</p> required <code>default</code> <code>Any</code> <p>Default value if key not found.</p> <code>None</code> <p>Returns:</p> Type Description <code>Any</code> <p>Metadata value or default.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.ExecutionContext.get_result","title":"<code>get_result() -&gt; Dict[str, Any]</code>","text":"<p>Get final execution result.</p> <p>Returns a generic result dictionary containing execution summary.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary with execution results and metadata.</p>"},{"location":"api/core/#stageresult","title":"StageResult","text":"<p>Represents the result of a stage execution.</p> <p>Uses slots for memory efficiency.</p> <p>Attributes:</p> Name Type Description <code>stage_name</code> <p>Name of the executed stage.</p> <code>result</code> <p>Result value from the stage handler.</p> <code>confidence</code> <p>Confidence score (0-1) if applicable.</p> <code>data</code> <p>Additional data returned by the stage.</p> <code>error</code> <p>Error message if stage failed.</p> <code>time_ms</code> <p>Execution time in milliseconds.</p>"},{"location":"api/core/#rotalabs_cascade.core.context.StageResult.__init__","title":"<code>__init__(stage_name: str, result: Any = None, confidence: Optional[float] = None, data: Optional[Dict[str, Any]] = None, error: Optional[str] = None, time_ms: float = 0.0)</code>","text":""},{"location":"api/core/#rotalabs_cascade.core.context.StageResult.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert stage result to dictionary.</p>"},{"location":"api/event/","title":"Event + Context Module","text":"<p>The event module provides domain-agnostic event and context models for cascade processing. These models work across all domains including finance, healthcare, cybersecurity, content moderation, and more.</p>"},{"location":"api/event/#universalevent","title":"UniversalEvent","text":"<p>Universal event structure that works across all domains.</p> <p>This abstraction allows the same cascade routing logic to work for: - Financial transactions - Healthcare claims - Content moderation posts - Security access attempts - Customer support tickets - And any other domain</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique event identifier</p> <code>domain</code> <code>DomainType</code> <p>The domain this event belongs to</p> <code>event_type</code> <code>str</code> <p>Type of event (transaction, post, claim, etc.)</p> <code>timestamp</code> <code>datetime</code> <p>When the event occurred</p> <code>primary_entity</code> <code>str</code> <p>Who initiated (user, customer, patient, employee)</p> <code>secondary_entity</code> <code>str</code> <p>Who received/target (merchant, provider, system)</p> <code>value</code> <code>float</code> <p>Numeric value (amount, size, count, severity 0-1)</p> <code>unit</code> <code>str</code> <p>Unit of value (USD, bytes, items, severity_score)</p> <code>domain_data</code> <code>Dict[str, Any]</code> <p>Domain-specific payload</p>"},{"location":"api/event/#rotalabs_cascade.core.event.UniversalEvent.__init__","title":"<code>__init__(id: str, domain: DomainType, event_type: str, timestamp: datetime, primary_entity: str, secondary_entity: str, value: float, unit: str, domain_data: Dict[str, Any] = dict(), correlation_id: Optional[str] = None, source_system: Optional[str] = None, event_version: str = '1.0') -&gt; None</code>","text":""},{"location":"api/event/#rotalabs_cascade.core.event.UniversalEvent.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert event to dictionary.</p>"},{"location":"api/event/#eventcontext","title":"EventContext","text":"<p>Complete contextual information surrounding an event.</p> <p>This structured context enables domain-agnostic routing rules that work across finance, healthcare, security, content, etc.</p>"},{"location":"api/event/#rotalabs_cascade.core.event.EventContext.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert context to dictionary.</p>"},{"location":"api/event/#eventwithcontext","title":"EventWithContext","text":"<p>Complete event package with context - the input to cascade processing.</p> <p>This is the primary input type for the CascadeEngine.execute() method. It combines what happened (Event) with the circumstances (Context).</p> Example <p>event = UniversalEvent( ...     id=\"evt_123\", ...     domain=DomainType.CONTENT_MODERATION, ...     event_type=\"post\", ...     timestamp=datetime.now(), ...     primary_entity=\"user_456\", ...     secondary_entity=\"forum_general\", ...     value=0.0,  # no monetary value ...     unit=\"post\", ...     domain_data={\"content\": \"Hello world\", \"has_media\": False} ... ) context = EventContext( ...     session=SessionContext(ip_address=\"1.2.3.4\"), ...     historical=HistoricalContext(account_age_days=30, previous_events_count=100) ... ) event_with_context = EventWithContext(event=event, context=context) result = await engine.execute(event_with_context)</p>"},{"location":"api/event/#rotalabs_cascade.core.event.EventWithContext.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert to dictionary for cascade processing.</p>"},{"location":"api/event/#rotalabs_cascade.core.event.EventWithContext.to_flat_dict","title":"<code>to_flat_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert to flat dictionary for backward compatibility.</p> <p>This allows the event+context to work with existing ExecutionContext that expects flat dictionary access like ctx.get(\"event.value\").</p>"},{"location":"api/event/#rotalabs_cascade.core.event.EventWithContext.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; EventWithContext</code>  <code>classmethod</code>","text":"<p>Parse from dictionary (e.g., API request).</p>"},{"location":"api/event/#domaintype","title":"DomainType","text":"<p>               Bases: <code>Enum</code></p> <p>Supported domain types for event processing.</p>"},{"location":"api/event/#sessioncontext","title":"SessionContext","text":"<p>Session-related contextual information.</p>"},{"location":"api/event/#devicecontext","title":"DeviceContext","text":"<p>Device-related contextual information.</p>"},{"location":"api/event/#locationcontext","title":"LocationContext","text":"<p>Location-related contextual information.</p>"},{"location":"api/event/#historicalcontext","title":"HistoricalContext","text":"<p>Historical behavioral contextual information.</p>"},{"location":"api/learning/","title":"Learning Module (APLS)","text":"<p>The learning module implements the Automatic Pattern Learning System (APLS) for cascade optimization. It extracts patterns from stage executions, generates routing rules, analyzes migration costs, and manages the rule proposal workflow.</p>"},{"location":"api/learning/#patternextractor","title":"PatternExtractor","text":"<p>Extracts patterns from cascade stage failures for optimization.</p> <p>The PatternExtractor analyzes stage results to identify recurring patterns that could potentially be moved to cheaper stages. For example, if an AI stage consistently catches a specific type of input based on certain feature combinations, that pattern could be encoded as a rule.</p> Example <p>extractor = PatternExtractor() pattern = extractor.learn_from_failure(context, \"ai_analysis\", result) if pattern: ...     print(f\"Learned pattern: {pattern.id}\") candidates = extractor.get_migration_candidates(min_confidence=0.9) insights = extractor.get_insights()</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.__init__","title":"<code>__init__(config: Optional[PatternConfig] = None)</code>","text":"<p>Initialize the pattern extractor.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>Optional[PatternConfig]</code> <p>Optional configuration for pattern extraction.</p> <code>None</code>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.learn_from_failure","title":"<code>learn_from_failure(context: ExecutionContext, stage: str, result: StageResult) -&gt; Optional[StageFailurePattern]</code>","text":"<p>Learn patterns from a stage failure or detection.</p> <p>Analyzes the execution context and stage result to extract patterns that characterize this type of detection.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>ExecutionContext</code> <p>The execution context containing input data.</p> required <code>stage</code> <code>str</code> <p>Name of the stage that detected/flagged the input.</p> required <code>result</code> <code>StageResult</code> <p>The stage result containing detection details.</p> required <p>Returns:</p> Type Description <code>Optional[StageFailurePattern]</code> <p>The extracted or updated pattern, or None if no pattern found.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.get_migration_candidates","title":"<code>get_migration_candidates(min_confidence: float = 0.8, min_samples: int = 10) -&gt; List[StageFailurePattern]</code>","text":"<p>Get patterns that are candidates for migration to cheaper stages.</p> <p>Returns patterns that have high confidence and sufficient samples to warrant consideration for migration.</p> <p>Parameters:</p> Name Type Description Default <code>min_confidence</code> <code>float</code> <p>Minimum confidence threshold.</p> <code>0.8</code> <code>min_samples</code> <code>int</code> <p>Minimum number of samples.</p> <code>10</code> <p>Returns:</p> Type Description <code>List[StageFailurePattern]</code> <p>List of patterns suitable for migration.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.get_insights","title":"<code>get_insights() -&gt; PatternLearningInsight</code>","text":"<p>Get aggregated learning insights.</p> <p>Computes overall statistics and recommendations from all learned patterns.</p> <p>Returns:</p> Type Description <code>PatternLearningInsight</code> <p>PatternLearningInsight with analysis and recommendations.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.clear_patterns","title":"<code>clear_patterns() -&gt; None</code>","text":"<p>Clear all learned patterns.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.get_pattern","title":"<code>get_pattern(pattern_id: str) -&gt; Optional[StageFailurePattern]</code>","text":"<p>Get a specific pattern by ID.</p> <p>Parameters:</p> Name Type Description Default <code>pattern_id</code> <code>str</code> <p>The pattern identifier.</p> required <p>Returns:</p> Type Description <code>Optional[StageFailurePattern]</code> <p>The pattern if found, None otherwise.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.get_patterns_by_stage","title":"<code>get_patterns_by_stage(stage: str) -&gt; List[StageFailurePattern]</code>","text":"<p>Get all patterns for a specific stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>The stage name.</p> required <p>Returns:</p> Type Description <code>List[StageFailurePattern]</code> <p>List of patterns for the stage.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.get_patterns_by_type","title":"<code>get_patterns_by_type(pattern_type: str) -&gt; List[StageFailurePattern]</code>","text":"<p>Get all patterns of a specific type.</p> <p>Parameters:</p> Name Type Description Default <code>pattern_type</code> <code>str</code> <p>The pattern type.</p> required <p>Returns:</p> Type Description <code>List[StageFailurePattern]</code> <p>List of patterns of the specified type.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.export_patterns","title":"<code>export_patterns() -&gt; List[Dict[str, Any]]</code>","text":"<p>Export all patterns as dictionaries.</p> <p>Returns:</p> Type Description <code>List[Dict[str, Any]]</code> <p>List of pattern dictionaries.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.PatternExtractor.import_patterns","title":"<code>import_patterns(patterns: List[Dict[str, Any]]) -&gt; int</code>","text":"<p>Import patterns from dictionaries.</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>List[Dict[str, Any]]</code> <p>List of pattern dictionaries.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Number of patterns imported.</p>"},{"location":"api/learning/#stagefailurepattern","title":"StageFailurePattern","text":"<p>Represents a pattern extracted from stage failures.</p> <p>Patterns capture recurring characteristics in data that cause specific stages to trigger. By identifying these patterns, we can potentially move detection to cheaper, earlier stages.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>str</code> <p>Unique identifier for this pattern.</p> <code>stage</code> <code>str</code> <p>Name of the cascade stage where this pattern was detected.</p> <code>pattern_type</code> <code>str</code> <p>Type of pattern (threshold, correlation, reasoning, temporal, behavioral).</p> <code>features</code> <code>Dict[str, Any]</code> <p>Extracted feature values that define this pattern.</p> <code>confidence</code> <code>float</code> <p>Confidence score (0-1) in this pattern's reliability.</p> <code>sample_count</code> <code>int</code> <p>Number of samples that matched this pattern.</p> <code>first_seen</code> <code>datetime</code> <p>Timestamp when pattern was first observed.</p> <code>last_seen</code> <code>datetime</code> <p>Timestamp when pattern was last observed.</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional pattern metadata.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.StageFailurePattern.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert pattern to dictionary representation.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.pattern_extractor.StageFailurePattern.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; StageFailurePattern</code>  <code>classmethod</code>","text":"<p>Create pattern from dictionary representation.</p>"},{"location":"api/learning/#rulegenerator","title":"RuleGenerator","text":"<p>Generates routing rules from learned patterns.</p> <p>This class analyzes patterns extracted from execution history and generates appropriate routing rules. It supports multiple generation strategies based on pattern type and can optionally use an LLM for complex rule generation.</p> <p>Attributes:</p> Name Type Description <code>llm_client</code> <p>Optional LLM client for generating complex rules.</p> <code>min_confidence</code> <p>Minimum confidence threshold for generating rules.</p> <code>min_coverage</code> <p>Minimum estimated coverage for generating rules.</p> Example <p>generator = RuleGenerator(min_confidence=0.7) pattern = StageFailurePattern(...) rule = generator.generate_from_pattern(pattern) if rule: ...     yaml_output = generator.to_yaml([rule])</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.RuleGenerator.__init__","title":"<code>__init__(llm_client: Optional[Any] = None, min_confidence: float = 0.5, min_coverage: float = 0.01) -&gt; None</code>","text":"<p>Initialize the rule generator.</p> <p>Parameters:</p> Name Type Description Default <code>llm_client</code> <code>Optional[Any]</code> <p>Optional LLM client for generating complex rules. Should have a method like <code>generate(prompt: str) -&gt; str</code>.</p> <code>None</code> <code>min_confidence</code> <code>float</code> <p>Minimum confidence threshold for rule generation.</p> <code>0.5</code> <code>min_coverage</code> <code>float</code> <p>Minimum estimated coverage threshold.</p> <code>0.01</code>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.RuleGenerator.generate_from_pattern","title":"<code>generate_from_pattern(pattern: StageFailurePattern) -&gt; Optional[GeneratedRule]</code>","text":"<p>Generate a routing rule from a pattern.</p> <p>This method selects the appropriate generation strategy based on the pattern type and attempts to create a rule.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>StageFailurePattern</code> <p>The pattern to generate a rule from.</p> required <p>Returns:</p> Type Description <code>Optional[GeneratedRule]</code> <p>A GeneratedRule if successful, None if the pattern cannot be</p> <code>Optional[GeneratedRule]</code> <p>converted to a rule or doesn't meet thresholds.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.RuleGenerator.to_routing_rule","title":"<code>to_routing_rule(generated: GeneratedRule) -&gt; RoutingRule</code>","text":"<p>Convert a GeneratedRule to cascade's RoutingRule format.</p> <p>This method transforms the generated rule into the native RoutingRule format used by the cascade engine.</p> <p>Parameters:</p> Name Type Description Default <code>generated</code> <code>GeneratedRule</code> <p>The GeneratedRule to convert.</p> required <p>Returns:</p> Type Description <code>RoutingRule</code> <p>A RoutingRule ready for use in cascade configuration.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.RuleGenerator.to_yaml","title":"<code>to_yaml(rules: List[GeneratedRule]) -&gt; str</code>","text":"<p>Export generated rules as YAML.</p> <p>This method exports rules in a human-readable YAML format suitable for review and manual editing.</p> <p>Parameters:</p> Name Type Description Default <code>rules</code> <code>List[GeneratedRule]</code> <p>List of GeneratedRule objects to export.</p> required <p>Returns:</p> Type Description <code>str</code> <p>YAML string representation of the rules.</p> <p>Raises:</p> Type Description <code>ImportError</code> <p>If PyYAML is not installed.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.RuleGenerator.generate_batch","title":"<code>generate_batch(patterns: List[StageFailurePattern]) -&gt; List[GeneratedRule]</code>","text":"<p>Generate rules from a batch of patterns.</p> <p>Convenience method for processing multiple patterns at once.</p> <p>Parameters:</p> Name Type Description Default <code>patterns</code> <code>List[StageFailurePattern]</code> <p>List of patterns to generate rules from.</p> required <p>Returns:</p> Type Description <code>List[GeneratedRule]</code> <p>List of successfully generated rules.</p>"},{"location":"api/learning/#generatedrule","title":"GeneratedRule","text":"<p>A routing rule generated from a learned pattern.</p> <p>This dataclass represents a machine-generated rule that can be proposed for human review before being deployed.</p> <p>Attributes:</p> Name Type Description <code>rule_id</code> <code>str</code> <p>Unique identifier for this rule.</p> <code>name</code> <code>str</code> <p>Human-readable rule name.</p> <code>description</code> <code>str</code> <p>Detailed description of what this rule does.</p> <code>template</code> <code>RuleTemplate</code> <p>The template type used to generate this rule.</p> <code>conditions</code> <code>List[Dict[str, Any]]</code> <p>List of condition specifications.</p> <code>action</code> <code>str</code> <p>The action to take when rule matches (APPROVE, REJECT, ESCALATE, FLAG).</p> <code>target_stage</code> <code>str</code> <p>The stage to route to when the rule matches.</p> <code>source_pattern_id</code> <code>str</code> <p>ID of the pattern this rule was generated from.</p> <code>confidence</code> <code>float</code> <p>Confidence score from the source pattern (0.0 to 1.0).</p> <code>estimated_coverage</code> <code>float</code> <p>Estimated percentage of cases this rule would handle.</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when this rule was generated.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.GeneratedRule.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert rule to dictionary representation.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representation of the generated rule.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.rule_generator.GeneratedRule.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; 'GeneratedRule'</code>  <code>classmethod</code>","text":"<p>Create rule from dictionary representation.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing rule data.</p> required <p>Returns:</p> Type Description <code>'GeneratedRule'</code> <p>GeneratedRule instance.</p>"},{"location":"api/learning/#costanalyzer","title":"CostAnalyzer","text":"<p>Analyzes migration costs and ROI for cascade pattern optimization.</p> <p>The CostAnalyzer evaluates whether patterns should be migrated between processing stages based on cost efficiency, detection rates, and risk factors. It uses configurable stage costs to model the tradeoffs between earlier (cheaper but less sophisticated) and later (expensive but more capable) stages.</p> Example <p>analyzer = CostAnalyzer()</p> <p>Attributes:</p> Name Type Description <code>stage_costs</code> <p>Dictionary mapping stage names to their cost configurations.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer--calculate-roi-for-a-single-pattern","title":"Calculate ROI for a single pattern","text":"<p>roi = analyzer.calculate_migration_roi(pattern, \"RULES\", volume=10000) print(f\"Recommendation: {roi.recommendation}\") print(f\"Savings: {roi.cost_reduction_absolute:.2f} per period\")</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.__init__","title":"<code>__init__(stage_costs: Optional[Dict[str, StageCost]] = None) -&gt; None</code>","text":"<p>Initialize the cost analyzer.</p> <p>Parameters:</p> Name Type Description Default <code>stage_costs</code> <code>Optional[Dict[str, StageCost]]</code> <p>Optional custom stage cost configuration. If not provided, uses DEFAULT_STAGE_COSTS.</p> <code>None</code>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.set_stage_cost","title":"<code>set_stage_cost(stage: str, cost: StageCost) -&gt; None</code>","text":"<p>Set or update the cost configuration for a stage.</p> <p>Parameters:</p> Name Type Description Default <code>stage</code> <code>str</code> <p>Stage identifier name.</p> required <code>cost</code> <code>StageCost</code> <p>Cost configuration for the stage.</p> required"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.calculate_migration_roi","title":"<code>calculate_migration_roi(pattern: 'StageFailurePattern', target_stage: str, volume: int, migration_effort: Optional[float] = None) -&gt; MigrationROI</code>","text":"<p>Calculate ROI for migrating a pattern to a different stage.</p> <p>Parameters:</p> Name Type Description Default <code>pattern</code> <code>'StageFailurePattern'</code> <p>The stage failure pattern to analyze.</p> required <code>target_stage</code> <code>str</code> <p>Stage to potentially migrate the pattern to.</p> required <code>volume</code> <code>int</code> <p>Estimated number of items per period.</p> required <code>migration_effort</code> <code>Optional[float]</code> <p>Cost units for migration effort (default: 100.0).</p> <code>None</code> <p>Returns:</p> Type Description <code>MigrationROI</code> <p>MigrationROI with cost analysis and recommendation.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If source or target stage is not configured.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.analyze_all_candidates","title":"<code>analyze_all_candidates(candidates: List['StageFailurePattern'], target_stage: str = 'RULES', volume: int = 1000) -&gt; List[MigrationROI]</code>","text":"<p>Analyze all candidate patterns for migration to a target stage.</p> <p>Parameters:</p> Name Type Description Default <code>candidates</code> <code>List['StageFailurePattern']</code> <p>List of stage failure patterns to analyze.</p> required <code>target_stage</code> <code>str</code> <p>Target stage for migration (default: RULES).</p> <code>'RULES'</code> <code>volume</code> <code>int</code> <p>Estimated items per period for each pattern.</p> <code>1000</code> <p>Returns:</p> Type Description <code>List[MigrationROI]</code> <p>List of MigrationROI objects for each candidate.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.get_total_potential_savings","title":"<code>get_total_potential_savings(roi_list: List[MigrationROI]) -&gt; Dict[str, Any]</code>","text":"<p>Calculate total potential savings from a list of ROI analyses.</p> <p>Parameters:</p> Name Type Description Default <code>roi_list</code> <code>List[MigrationROI]</code> <p>List of MigrationROI objects to aggregate.</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing: - total_absolute_savings: Sum of all cost reductions. - total_volume: Sum of all estimated volumes. - average_reduction_percentage: Weighted average cost reduction. - migrate_count: Number of MIGRATE recommendations. - monitor_count: Number of MONITOR recommendations. - reject_count: Number of REJECT recommendations. - patterns_by_recommendation: Pattern IDs grouped by recommendation.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.CostAnalyzer.rank_by_roi","title":"<code>rank_by_roi(roi_list: List[MigrationROI], ascending: bool = False) -&gt; List[MigrationROI]</code>","text":"<p>Rank migration candidates by ROI.</p> <p>Patterns are ranked primarily by cost reduction absolute value, with recommendation and false positive risk as secondary factors.</p> <p>Parameters:</p> Name Type Description Default <code>roi_list</code> <code>List[MigrationROI]</code> <p>List of MigrationROI objects to rank.</p> required <code>ascending</code> <code>bool</code> <p>If True, rank from lowest to highest ROI.</p> <code>False</code> <p>Returns:</p> Type Description <code>List[MigrationROI]</code> <p>Sorted list of MigrationROI objects.</p>"},{"location":"api/learning/#migrationroi","title":"MigrationROI","text":"<p>ROI calculation for migrating a pattern to a different stage.</p> <p>Attributes:</p> Name Type Description <code>pattern_id</code> <code>str</code> <p>Unique identifier for the pattern being analyzed.</p> <code>source_stage</code> <code>str</code> <p>Current stage where pattern is being handled.</p> <code>target_stage</code> <code>str</code> <p>Proposed stage to migrate pattern to.</p> <code>current_cost_per_item</code> <code>float</code> <p>Cost per item at current stage.</p> <code>projected_cost_per_item</code> <code>float</code> <p>Expected cost per item at target stage.</p> <code>estimated_volume</code> <code>int</code> <p>Expected items per period to process.</p> <code>cost_reduction_absolute</code> <code>float</code> <p>Total cost savings per period.</p> <code>cost_reduction_percentage</code> <code>float</code> <p>Percentage reduction in costs.</p> <code>detection_rate_change</code> <code>float</code> <p>Change in detection rate (positive = improvement).</p> <code>false_positive_risk</code> <code>float</code> <p>Risk of false positives at target stage (0.0-1.0).</p> <code>payback_items</code> <code>int</code> <p>Number of items needed to break even on migration effort.</p> <code>recommendation</code> <code>str</code> <p>Migration recommendation (MIGRATE, MONITOR, REJECT).</p>"},{"location":"api/learning/#rotalabs_cascade.learning.cost_analyzer.MigrationROI.__post_init__","title":"<code>__post_init__() -&gt; None</code>","text":"<p>Validate recommendation value.</p>"},{"location":"api/learning/#proposalmanager","title":"ProposalManager","text":"<p>Manages the lifecycle of rule proposals through the approval workflow.</p> <p>This class provides methods for creating, reviewing, testing, and activating rule proposals. It supports optional file-based persistence for proposals.</p> <p>Attributes:</p> Name Type Description <code>storage_path</code> <p>Optional path for persisting proposals to disk.</p> <code>_proposals</code> <code>Dict[str, RuleProposal]</code> <p>In-memory dictionary of proposals keyed by proposal_id.</p> Example <p>manager = ProposalManager(storage_path=Path(\"./proposals\")) proposal = manager.create_proposal(rule, roi) pending = manager.get_pending_proposals() manager.approve(proposal.proposal_id, \"reviewer@example.com\")</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.__init__","title":"<code>__init__(storage_path: Optional[Path] = None) -&gt; None</code>","text":"<p>Initialize the proposal manager.</p> <p>Parameters:</p> Name Type Description Default <code>storage_path</code> <code>Optional[Path]</code> <p>Optional path for file-based persistence. If provided, proposals will be saved to and loaded from this directory.</p> <code>None</code>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.create_proposal","title":"<code>create_proposal(rule: Any, roi: Any) -&gt; RuleProposal</code>","text":"<p>Create a new rule proposal for review.</p> <p>Parameters:</p> Name Type Description Default <code>rule</code> <code>Any</code> <p>The machine-generated rule to propose.</p> required <code>roi</code> <code>Any</code> <p>ROI analysis supporting this proposal.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The created RuleProposal with PENDING_REVIEW status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.get_pending_proposals","title":"<code>get_pending_proposals() -&gt; List[RuleProposal]</code>","text":"<p>Get all proposals pending review.</p> <p>Returns:</p> Type Description <code>List[RuleProposal]</code> <p>List of proposals with PENDING_REVIEW status, sorted by creation time.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.approve","title":"<code>approve(proposal_id: str, reviewer: str, notes: Optional[str] = None) -&gt; RuleProposal</code>","text":"<p>Approve a pending proposal.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to approve.</p> required <code>reviewer</code> <code>str</code> <p>Identifier of the person approving.</p> required <code>notes</code> <code>Optional[str]</code> <p>Optional notes explaining the approval decision.</p> <code>None</code> <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with APPROVED status.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in PENDING_REVIEW status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.reject","title":"<code>reject(proposal_id: str, reviewer: str, notes: str) -&gt; RuleProposal</code>","text":"<p>Reject a pending proposal.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to reject.</p> required <code>reviewer</code> <code>str</code> <p>Identifier of the person rejecting.</p> required <code>notes</code> <code>str</code> <p>Required notes explaining the rejection reason.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with REJECTED status.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in PENDING_REVIEW status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.start_testing","title":"<code>start_testing(proposal_id: str) -&gt; RuleProposal</code>","text":"<p>Start A/B testing for an approved proposal.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to begin testing.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with TESTING status.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in APPROVED status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.record_test_results","title":"<code>record_test_results(proposal_id: str, results: Dict[str, Any]) -&gt; RuleProposal</code>","text":"<p>Record test results for a proposal in testing.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal being tested.</p> required <code>results</code> <code>Dict[str, Any]</code> <p>Dictionary of test results and metrics.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with recorded test results.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in TESTING status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.activate","title":"<code>activate(proposal_id: str) -&gt; RuleProposal</code>","text":"<p>Activate a tested proposal for production use.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to activate.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with ACTIVE status.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in TESTING or APPROVED status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.deprecate","title":"<code>deprecate(proposal_id: str, reason: str) -&gt; RuleProposal</code>","text":"<p>Deprecate an active proposal.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to deprecate.</p> required <code>reason</code> <code>str</code> <p>Reason for deprecation.</p> required <p>Returns:</p> Type Description <code>RuleProposal</code> <p>The updated RuleProposal with DEPRECATED status.</p> <p>Raises:</p> Type Description <code>KeyError</code> <p>If proposal_id not found.</p> <code>ValueError</code> <p>If proposal is not in ACTIVE status.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.get_proposal","title":"<code>get_proposal(proposal_id: str) -&gt; Optional[RuleProposal]</code>","text":"<p>Get a proposal by ID.</p> <p>Parameters:</p> Name Type Description Default <code>proposal_id</code> <code>str</code> <p>ID of the proposal to retrieve.</p> required <p>Returns:</p> Type Description <code>Optional[RuleProposal]</code> <p>The RuleProposal if found, None otherwise.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.get_active_rules","title":"<code>get_active_rules() -&gt; List[RuleProposal]</code>","text":"<p>Get all active rule proposals.</p> <p>Returns:</p> Type Description <code>List[RuleProposal]</code> <p>List of proposals with ACTIVE status, sorted by activation time.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.export_proposals","title":"<code>export_proposals(path: Path) -&gt; None</code>","text":"<p>Export all proposals to a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to write the JSON file.</p> required"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.ProposalManager.import_proposals","title":"<code>import_proposals(path: Path) -&gt; None</code>","text":"<p>Import proposals from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to the JSON file to import.</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the file does not exist.</p> <code>JSONDecodeError</code> <p>If the file is not valid JSON.</p>"},{"location":"api/learning/#ruleproposal","title":"RuleProposal","text":"<p>A proposal for a machine-generated routing rule.</p> <p>This dataclass captures all metadata about a rule proposal throughout its lifecycle, from initial creation through review, testing, and activation.</p> <p>Attributes:</p> Name Type Description <code>proposal_id</code> <code>str</code> <p>Unique identifier for this proposal.</p> <code>generated_rule</code> <code>Any</code> <p>The machine-generated rule being proposed.</p> <code>roi_analysis</code> <code>Any</code> <p>ROI analysis supporting this proposal.</p> <code>status</code> <code>ProposalStatus</code> <p>Current status in the approval workflow.</p> <code>created_at</code> <code>datetime</code> <p>Timestamp when proposal was created.</p> <code>reviewed_at</code> <code>Optional[datetime]</code> <p>Timestamp when proposal was reviewed (approved/rejected).</p> <code>reviewer</code> <code>Optional[str]</code> <p>Identifier of the person who reviewed the proposal.</p> <code>review_notes</code> <code>Optional[str]</code> <p>Notes from the reviewer explaining their decision.</p> <code>test_results</code> <code>Optional[Dict[str, Any]]</code> <p>Results from A/B testing phase.</p> <code>activated_at</code> <code>Optional[datetime]</code> <p>Timestamp when proposal was activated in production.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.RuleProposal.to_dict","title":"<code>to_dict() -&gt; Dict[str, Any]</code>","text":"<p>Convert proposal to dictionary for serialization.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary representation of the proposal.</p>"},{"location":"api/learning/#rotalabs_cascade.learning.proposal.RuleProposal.from_dict","title":"<code>from_dict(data: Dict[str, Any]) -&gt; 'RuleProposal'</code>  <code>classmethod</code>","text":"<p>Create proposal from dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>Dict[str, Any]</code> <p>Dictionary containing proposal data.</p> required <p>Returns:</p> Type Description <code>'RuleProposal'</code> <p>RuleProposal instance.</p>"},{"location":"api/plugins/","title":"Plugins Module","text":"<p>The plugins module provides built-in plugin implementations for extending cascade stage handlers with caching, retry logic, metrics collection, and circuit breaking.</p>"},{"location":"api/plugins/#cacheplugin","title":"CachePlugin","text":"<p>               Bases: <code>StagePlugin</code></p> <p>Plugin for caching stage execution results.</p> <p>Caches results based on input context hash with configurable TTL. Cache entries expire after ttl_seconds.</p> <p>Attributes:</p> Name Type Description <code>wrapped_handler</code> <p>The underlying handler to cache</p> <code>ttl_seconds</code> <p>Time-to-live for cache entries in seconds</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CachePlugin.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CachePlugin.__init__","title":"<code>__init__(wrapped_handler: Callable, ttl_seconds: int = 300)</code>","text":"<p>Initialize cache plugin.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_handler</code> <code>Callable</code> <p>Handler function to wrap with caching</p> required <code>ttl_seconds</code> <code>int</code> <p>Cache entry TTL in seconds (default: 300)</p> <code>300</code>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CachePlugin.execute","title":"<code>execute(context: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Execute with caching.</p> <p>Checks cache for existing result. If cache miss or expired, executes wrapped handler and stores result.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Dict[str, Any]</code> <p>Execution context</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Cached or newly computed result</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Any errors from wrapped handler</p>"},{"location":"api/plugins/#retryplugin","title":"RetryPlugin","text":"<p>               Bases: <code>StagePlugin</code></p> <p>Plugin for retry logic with exponential backoff.</p> <p>Retries failed executions with exponential backoff between attempts.</p> <p>Attributes:</p> Name Type Description <code>wrapped_handler</code> <p>The underlying handler to retry</p> <code>max_retries</code> <p>Maximum number of retry attempts</p> <code>delay_ms</code> <p>Initial delay between retries in milliseconds</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.RetryPlugin.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.RetryPlugin.__init__","title":"<code>__init__(wrapped_handler: Callable, max_retries: int = 3, delay_ms: int = 100)</code>","text":"<p>Initialize retry plugin.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_handler</code> <code>Callable</code> <p>Handler function to wrap with retries</p> required <code>max_retries</code> <code>int</code> <p>Maximum retry attempts (default: 3)</p> <code>3</code> <code>delay_ms</code> <code>int</code> <p>Initial delay in milliseconds (default: 100)</p> <code>100</code>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.RetryPlugin.execute","title":"<code>execute(context: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Execute with retry logic.</p> <p>Attempts execution up to max_retries times with exponential backoff. Delay doubles after each failed attempt.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Dict[str, Any]</code> <p>Execution context</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Result from successful execution</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Last exception if all retries exhausted</p>"},{"location":"api/plugins/#metricsplugin","title":"MetricsPlugin","text":"<p>               Bases: <code>StagePlugin</code></p> <p>Plugin for collecting execution metrics.</p> <p>Tracks execution count, total time, errors, and computes success rate and average execution time.</p> <p>Attributes:</p> Name Type Description <code>wrapped_handler</code> <p>The underlying handler to monitor</p> <code>count</code> <p>Total number of executions</p> <code>total_time_ms</code> <p>Total execution time in milliseconds</p> <code>errors</code> <p>Number of failed executions</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.success_rate","title":"<code>success_rate: float</code>  <code>property</code>","text":"<p>Calculate success rate.</p> <p>Returns:</p> Type Description <code>float</code> <p>Success rate as percentage (0-100)</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.avg_time_ms","title":"<code>avg_time_ms: float</code>  <code>property</code>","text":"<p>Calculate average execution time.</p> <p>Returns:</p> Type Description <code>float</code> <p>Average time in milliseconds</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.metrics","title":"<code>metrics: Dict[str, Any]</code>  <code>property</code>","text":"<p>Get current metrics.</p> <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Dictionary containing all metrics</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.__init__","title":"<code>__init__(wrapped_handler: Callable)</code>","text":"<p>Initialize metrics plugin.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_handler</code> <code>Callable</code> <p>Handler function to wrap with metrics</p> required"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.MetricsPlugin.execute","title":"<code>execute(context: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Execute with metrics collection.</p> <p>Times execution and updates metrics counters.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Dict[str, Any]</code> <p>Execution context</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Result from wrapped handler</p> <p>Raises:</p> Type Description <code>Exception</code> <p>Any errors from wrapped handler (recorded in metrics)</p>"},{"location":"api/plugins/#circuitbreakerplugin","title":"CircuitBreakerPlugin","text":"<p>               Bases: <code>StagePlugin</code></p> <p>Plugin implementing circuit breaker pattern.</p> <p>Prevents cascading failures by opening circuit after threshold failures. Circuit automatically resets after timeout period.</p> States <ul> <li>CLOSED: Normal operation, requests pass through</li> <li>OPEN: Circuit tripped, requests fail immediately</li> <li>HALF_OPEN: Testing if service recovered (auto after timeout)</li> </ul> <p>Attributes:</p> Name Type Description <code>wrapped_handler</code> <p>The underlying handler to protect</p> <code>failure_threshold</code> <p>Number of failures before opening circuit</p> <code>reset_timeout_seconds</code> <p>Time before attempting reset</p> <code>failure_count</code> <p>Current consecutive failure count</p> <code>last_failure_time</code> <code>Optional[float]</code> <p>Timestamp of last failure</p> <code>is_open</code> <p>Whether circuit is currently open</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CircuitBreakerPlugin.name","title":"<code>name: str</code>  <code>property</code>","text":"<p>Get plugin name.</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CircuitBreakerPlugin.__init__","title":"<code>__init__(wrapped_handler: Callable, failure_threshold: int = 5, reset_timeout_seconds: int = 60)</code>","text":"<p>Initialize circuit breaker plugin.</p> <p>Parameters:</p> Name Type Description Default <code>wrapped_handler</code> <code>Callable</code> <p>Handler function to protect</p> required <code>failure_threshold</code> <code>int</code> <p>Failures before opening (default: 5)</p> <code>5</code> <code>reset_timeout_seconds</code> <code>int</code> <p>Timeout before reset attempt (default: 60)</p> <code>60</code>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.CircuitBreakerPlugin.execute","title":"<code>execute(context: Dict[str, Any]) -&gt; Dict[str, Any]</code>  <code>async</code>","text":"<p>Execute with circuit breaker protection.</p> <p>Checks circuit state before execution. If open, fails immediately unless timeout has passed (half-open state).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>Dict[str, Any]</code> <p>Execution context</p> required <p>Returns:</p> Type Description <code>Dict[str, Any]</code> <p>Result from successful execution</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If circuit is open</p> <code>Exception</code> <p>Any errors from wrapped handler</p>"},{"location":"api/plugins/#pluginfactory","title":"PluginFactory","text":"<p>Factory for composing plugins around handlers.</p> <p>Provides utilities for wrapping handlers with multiple plugins in a composable manner. Plugins are applied in reverse order so that the first plugin in the list is the outermost wrapper.</p>"},{"location":"api/plugins/#rotalabs_cascade.plugins.builtin.PluginFactory.wrap_handler","title":"<code>wrap_handler(handler: Callable, plugins: List[str], config: Dict[str, Any]) -&gt; Callable</code>  <code>async</code> <code>staticmethod</code>","text":"<p>Wrap a handler with multiple plugins.</p> <p>Applies plugins in reverse order to create a plugin chain: cache -&gt; retry -&gt; metrics -&gt; circuit_breaker -&gt; handler</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>Callable</code> <p>Base handler to wrap</p> required <code>plugins</code> <code>List[str]</code> <p>List of plugin names to apply (e.g., [\"cache\", \"retry\"])</p> required <code>config</code> <code>Dict[str, Any]</code> <p>Configuration dict with plugin-specific settings    Example: {        \"cache\": {\"ttl_seconds\": 600},        \"retry\": {\"max_retries\": 5},        \"circuit_breaker\": {\"failure_threshold\": 3}    }</p> required <p>Returns:</p> Type Description <code>Callable</code> <p>Wrapped handler with all plugins applied</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If unknown plugin name provided</p>"},{"location":"tutorials/apls-learning/","title":"Cost Optimization with APLS","text":"<p>The Adaptive Pattern Learning System (APLS) is a cost optimization framework within rotalabs-cascade that learns from expensive stage executions to generate cheaper rules. When your AI stage consistently catches similar patterns, APLS extracts those patterns and proposes rules that can be executed in earlier, cheaper stages.</p>"},{"location":"tutorials/apls-learning/#the-cost-problem","title":"The Cost Problem","text":"<p>In a typical cascade system, costs vary dramatically between stages:</p> Stage Relative Cost Latency Use Case RULES 1x ~1ms Deterministic checks STATISTICAL_ML 5x ~10ms Trained model inference SINGLE_AI 25x ~100ms Single LLM call POD 100x ~500ms Multi-agent deliberation ADVERSARIAL 500x ~2000ms Adversarial probing <p>If 30% of your AI decisions follow predictable patterns, converting those patterns to rules could reduce costs by 95% for that traffic.</p>"},{"location":"tutorials/apls-learning/#the-5-level-cost-model","title":"The 5-Level Cost Model","text":"<p>APLS uses a hierarchical cost model defined in <code>CostAnalyzer</code>:</p> <pre><code>from rotalabs_cascade import CostAnalyzer, StageCost\n\n# Default cost configuration\nDEFAULT_STAGE_COSTS = {\n    \"RULES\": StageCost(\n        stage=\"RULES\",\n        base_cost=1.0,      # Baseline cost\n        latency_ms=1.0,\n        resource_units=0.1,\n    ),\n    \"STATISTICAL_ML\": StageCost(\n        stage=\"STATISTICAL_ML\",\n        base_cost=5.0,      # 5x rules\n        latency_ms=10.0,\n        resource_units=0.5,\n    ),\n    \"SINGLE_AI\": StageCost(\n        stage=\"SINGLE_AI\",\n        base_cost=25.0,     # 25x rules\n        latency_ms=100.0,\n        resource_units=2.0,\n    ),\n    \"POD\": StageCost(\n        stage=\"POD\",\n        base_cost=100.0,    # 100x rules\n        latency_ms=500.0,\n        resource_units=10.0,\n    ),\n    \"ADVERSARIAL\": StageCost(\n        stage=\"ADVERSARIAL\",\n        base_cost=500.0,    # 500x rules\n        latency_ms=2000.0,\n        resource_units=50.0,\n    ),\n}\n</code></pre>"},{"location":"tutorials/apls-learning/#customizing-stage-costs","title":"Customizing Stage Costs","text":"<p>You can configure costs to match your actual infrastructure:</p> <pre><code>from rotalabs_cascade import CostAnalyzer, StageCost\n\n# Create analyzer with default costs\nanalyzer = CostAnalyzer()\n\n# Add or update a custom stage\nanalyzer.set_stage_cost(\"CUSTOM_STAGE\", StageCost(\n    stage=\"CUSTOM_STAGE\",\n    base_cost=15.0,\n    latency_ms=50.0,\n    resource_units=1.5,\n))\n\n# Or initialize with all custom costs\ncustom_costs = {\n    \"RULES\": StageCost(stage=\"RULES\", base_cost=1.0, latency_ms=1.0, resource_units=0.1),\n    \"ML\": StageCost(stage=\"ML\", base_cost=10.0, latency_ms=20.0, resource_units=1.0),\n    \"AI\": StageCost(stage=\"AI\", base_cost=50.0, latency_ms=200.0, resource_units=5.0),\n}\nanalyzer = CostAnalyzer(stage_costs=custom_costs)\n</code></pre>"},{"location":"tutorials/apls-learning/#apls-components","title":"APLS Components","text":"<p>The APLS system consists of four main components:</p> <ol> <li>PatternExtractor: Learns patterns from stage failures/detections</li> <li>RuleGenerator: Converts patterns into routing rules</li> <li>CostAnalyzer: Calculates ROI for pattern migrations</li> <li>ProposalManager: Manages the human approval workflow</li> </ol>"},{"location":"tutorials/apls-learning/#component-1-patternextractor","title":"Component 1: PatternExtractor","text":"<p>The <code>PatternExtractor</code> observes stage executions and extracts recurring patterns that could be moved to earlier stages.</p>"},{"location":"tutorials/apls-learning/#pattern-types","title":"Pattern Types","text":"<p>APLS extracts five types of patterns:</p> Type Description Example <code>threshold</code> Simple value comparisons <code>amount &gt; 5000</code> <code>correlation</code> Feature combinations <code>new_account AND high_value</code> <code>reasoning</code> AI explanation patterns Keywords and factors from AI reasoning <code>temporal</code> Time-based patterns Peak hours, processing time thresholds <code>behavioral</code> Execution flow patterns Stage sequences, routing decisions"},{"location":"tutorials/apls-learning/#using-patternextractor","title":"Using PatternExtractor","text":"<pre><code>from rotalabs_cascade import (\n    PatternExtractor,\n    PatternConfig,\n    ExecutionContext,\n    StageResult,\n)\n\n# Configure the extractor\nconfig = PatternConfig(\n    min_confidence=0.7,           # Minimum confidence to extract pattern\n    min_samples_for_candidate=10, # Samples needed before migration consideration\n    max_patterns=1000,            # Maximum patterns to track (LRU eviction)\n    pattern_ttl_hours=168,        # Patterns expire after 7 days without updates\n    enable_threshold_extraction=True,\n    enable_correlation_extraction=True,\n    enable_reasoning_extraction=True,\n    enable_temporal_extraction=True,\n    enable_behavioral_extraction=True,\n)\n\n# Create the extractor\nextractor = PatternExtractor(config)\n</code></pre>"},{"location":"tutorials/apls-learning/#learning-from-stage-executions","title":"Learning from Stage Executions","text":"<p>After each cascade execution, feed the results to the extractor:</p> <pre><code>async def process_and_learn(engine, extractor, event_with_context):\n    \"\"\"Execute cascade and learn from results.\"\"\"\n    # Execute the cascade\n    result = await engine.execute(event_with_context)\n\n    # Create execution context for learning\n    context = ExecutionContext(event_with_context)\n\n    # Learn from each stage that executed\n    for stage_name, stage_data in result[\"stage_results\"].items():\n        stage_result = StageResult(\n            stage_name=stage_name,\n            result=stage_data.get(\"result\"),\n            confidence=stage_data.get(\"confidence\"),\n            data=stage_data.get(\"data\", {}),\n            time_ms=stage_data.get(\"time_ms\", 0),\n        )\n\n        # Learn from stages that made decisions (not just passed through)\n        if stage_result.result in (\"REJECT\", \"FLAG\", \"ESCALATE\"):\n            pattern = extractor.learn_from_failure(\n                context=context,\n                stage=stage_name,\n                result=stage_result,\n            )\n            if pattern:\n                print(f\"Learned pattern {pattern.id} from {stage_name}\")\n\n    return result\n</code></pre>"},{"location":"tutorials/apls-learning/#getting-migration-candidates","title":"Getting Migration Candidates","text":"<p>Once enough patterns accumulate, query for migration candidates:</p> <pre><code># Get patterns ready for migration\ncandidates = extractor.get_migration_candidates(\n    min_confidence=0.8,\n    min_samples=10,\n)\n\nprint(f\"Found {len(candidates)} migration candidates\")\n\nfor pattern in candidates:\n    print(f\"  Pattern {pattern.id}:\")\n    print(f\"    Stage: {pattern.stage}\")\n    print(f\"    Type: {pattern.pattern_type}\")\n    print(f\"    Confidence: {pattern.confidence:.2%}\")\n    print(f\"    Samples: {pattern.sample_count}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#getting-insights","title":"Getting Insights","text":"<p>Get aggregated insights about learned patterns:</p> <pre><code>insights = extractor.get_insights()\n\nprint(f\"Total patterns: {len(insights.patterns)}\")\nprint(f\"Migration candidates: {len(insights.migration_candidates)}\")\nprint(f\"Estimated cost reduction: {insights.estimated_cost_reduction:.1%}\")\nprint(f\"Detection rate impact: {insights.detection_rate_impact:.2%}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#component-2-rulegenerator","title":"Component 2: RuleGenerator","text":"<p>The <code>RuleGenerator</code> converts extracted patterns into routing rules that can be deployed to earlier stages.</p>"},{"location":"tutorials/apls-learning/#generating-rules-from-patterns","title":"Generating Rules from Patterns","text":"<pre><code>from rotalabs_cascade import RuleGenerator\n\n# Create the generator\ngenerator = RuleGenerator(\n    min_confidence=0.7,    # Minimum pattern confidence to generate rule\n    min_coverage=0.01,     # Minimum estimated coverage\n)\n\n# Generate rules from all candidates\nrules = []\nfor pattern in candidates:\n    rule = generator.generate_from_pattern(pattern)\n    if rule:\n        rules.append(rule)\n        print(f\"Generated rule: {rule.name}\")\n        print(f\"  Template: {rule.template.value}\")\n        print(f\"  Conditions: {rule.conditions}\")\n        print(f\"  Action: {rule.action}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#rule-templates","title":"Rule Templates","text":"<p>The generator produces different rule templates based on pattern type:</p> <pre><code>from rotalabs_cascade import RuleTemplate\n\n# VALUE_THRESHOLD - Simple numeric comparisons\n# Generated from: threshold patterns\n# Example: value &gt;= 5000\n\n# MULTI_CONDITION - AND/OR combinations\n# Generated from: correlation and reasoning patterns\n# Example: new_account AND high_value AND unusual_location\n\n# PATTERN_MATCH - Regex matching\n# Generated from: reasoning patterns with keywords\n# Example: content MATCHES \"buy|sell|offer\"\n\n# TEMPORAL - Time-based rules\n# Generated from: temporal patterns\n# Example: hour &gt;= 22 OR hour &lt;= 6\n\n# BEHAVIORAL - Execution flow rules\n# Generated from: behavioral patterns\n# Example: stage_count &gt;= 3 AND avg_confidence &lt; 0.6\n</code></pre>"},{"location":"tutorials/apls-learning/#converting-to-routingrule","title":"Converting to RoutingRule","text":"<p>Generated rules can be converted to the cascade's native <code>RoutingRule</code> format:</p> <pre><code># Convert GeneratedRule to RoutingRule for cascade config\nfor generated_rule in rules:\n    routing_rule = generator.to_routing_rule(generated_rule)\n    print(f\"Routing rule: {routing_rule.name}\")\n    print(f\"  Type: {routing_rule.type}\")\n    print(f\"  Priority: {routing_rule.priority}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#batch-processing","title":"Batch Processing","text":"<p>Generate rules from multiple patterns at once:</p> <pre><code># Generate rules from all patterns\nrules = generator.generate_batch(candidates)\nprint(f\"Generated {len(rules)} rules from {len(candidates)} patterns\")\n</code></pre>"},{"location":"tutorials/apls-learning/#exporting-to-yaml","title":"Exporting to YAML","text":"<p>Export generated rules for review:</p> <pre><code>yaml_output = generator.to_yaml(rules)\nprint(yaml_output)\n</code></pre> <p>Output:</p> <pre><code>generated_rules:\n  - rule_id: rule_abc123\n    name: threshold_AI_value\n    description: Route when value is greater than or equal to 5000...\n    template: value_threshold\n    conditions:\n      - field: value\n        operator: \"&gt;=\"\n        value: 5000\n    action: APPROVE\n    target_stage: RULES\n    source_pattern_id: pat_xyz\n    confidence: 0.92\n    estimated_coverage: 0.08\n    created_at: '2024-01-15T10:30:00+00:00'\nmetadata:\n  generated_at: '2024-01-15T10:30:00+00:00'\n  rule_count: 5\n  templates_used:\n    - value_threshold\n    - multi_condition\n</code></pre>"},{"location":"tutorials/apls-learning/#component-3-costanalyzer","title":"Component 3: CostAnalyzer","text":"<p>The <code>CostAnalyzer</code> calculates the ROI of migrating patterns to cheaper stages.</p>"},{"location":"tutorials/apls-learning/#calculating-migration-roi","title":"Calculating Migration ROI","text":"<pre><code>from rotalabs_cascade import CostAnalyzer, MigrationROI\n\nanalyzer = CostAnalyzer()\n\n# Calculate ROI for a single pattern\nfor pattern in candidates:\n    roi = analyzer.calculate_migration_roi(\n        pattern=pattern,\n        target_stage=\"RULES\",      # Migrate to RULES stage\n        volume=10000,              # Expected events per period\n        migration_effort=100.0,    # One-time migration cost\n    )\n\n    print(f\"Pattern {pattern.id} -&gt; RULES:\")\n    print(f\"  Current cost/item: {roi.current_cost_per_item:.2f}\")\n    print(f\"  Projected cost/item: {roi.projected_cost_per_item:.2f}\")\n    print(f\"  Cost reduction: {roi.cost_reduction_percentage:.1f}%\")\n    print(f\"  Absolute savings: {roi.cost_reduction_absolute:.2f}\")\n    print(f\"  False positive risk: {roi.false_positive_risk:.2%}\")\n    print(f\"  Payback items: {roi.payback_items}\")\n    print(f\"  Recommendation: {roi.recommendation}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#migrationroi-fields","title":"MigrationROI Fields","text":"<p>The <code>MigrationROI</code> dataclass contains:</p> <pre><code>@dataclass\nclass MigrationROI:\n    pattern_id: str                  # Pattern being analyzed\n    source_stage: str                # Current stage\n    target_stage: str                # Proposed target stage\n    current_cost_per_item: float     # Cost at current stage\n    projected_cost_per_item: float   # Cost at target stage\n    estimated_volume: int            # Expected items per period\n    cost_reduction_absolute: float   # Total savings per period\n    cost_reduction_percentage: float # Percentage reduction\n    detection_rate_change: float     # Impact on detection rate\n    false_positive_risk: float       # Risk of false positives (0-1)\n    payback_items: int               # Items to break even\n    recommendation: str              # MIGRATE, MONITOR, or REJECT\n</code></pre>"},{"location":"tutorials/apls-learning/#recommendations","title":"Recommendations","text":"<p>The analyzer provides three recommendations:</p> <ul> <li>MIGRATE: High confidence pattern with significant savings (&gt;20% reduction, &gt;80% confidence)</li> <li>MONITOR: Moderate savings or confidence, worth tracking</li> <li>REJECT: Too risky (high false positive risk) or insufficient savings (&lt;5%)</li> </ul>"},{"location":"tutorials/apls-learning/#analyzing-all-candidates","title":"Analyzing All Candidates","text":"<pre><code># Analyze all candidates for migration to RULES\nroi_results = analyzer.analyze_all_candidates(\n    candidates=candidates,\n    target_stage=\"RULES\",\n    volume=10000,\n)\n\n# Get total potential savings\nsavings = analyzer.get_total_potential_savings(roi_results)\n\nprint(f\"Total potential savings: {savings['total_absolute_savings']:.2f}\")\nprint(f\"Average reduction: {savings['average_reduction_percentage']:.1f}%\")\nprint(f\"Patterns to migrate: {savings['migrate_count']}\")\nprint(f\"Patterns to monitor: {savings['monitor_count']}\")\nprint(f\"Patterns rejected: {savings['reject_count']}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#ranking-by-roi","title":"Ranking by ROI","text":"<p>Get the highest-impact migrations first:</p> <pre><code># Rank by ROI (highest savings first)\nranked = analyzer.rank_by_roi(roi_results, ascending=False)\n\nprint(\"Top 5 migration opportunities:\")\nfor roi in ranked[:5]:\n    print(f\"  {roi.pattern_id}: {roi.cost_reduction_absolute:.2f} savings\")\n</code></pre>"},{"location":"tutorials/apls-learning/#component-4-proposalmanager","title":"Component 4: ProposalManager","text":"<p>The <code>ProposalManager</code> handles the human-in-the-loop approval workflow for generated rules.</p>"},{"location":"tutorials/apls-learning/#proposal-lifecycle","title":"Proposal Lifecycle","text":"<pre><code>PENDING_REVIEW -&gt; APPROVED -&gt; TESTING -&gt; ACTIVE\n                     |\n                     v\n                  REJECTED\n\nACTIVE -&gt; DEPRECATED\n</code></pre>"},{"location":"tutorials/apls-learning/#creating-proposals","title":"Creating Proposals","text":"<pre><code>from rotalabs_cascade import ProposalManager\nfrom pathlib import Path\n\n# Create manager with optional persistence\nmanager = ProposalManager(storage_path=Path(\"./proposals\"))\n\n# Create proposals from generated rules and ROI analysis\nfor rule, roi in zip(rules, roi_results):\n    if roi.recommendation == \"MIGRATE\":\n        proposal = manager.create_proposal(\n            rule=rule,\n            roi=roi,\n        )\n        print(f\"Created proposal {proposal.proposal_id}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#reviewing-proposals","title":"Reviewing Proposals","text":"<pre><code># Get pending proposals\npending = manager.get_pending_proposals()\n\nfor proposal in pending:\n    print(f\"Proposal {proposal.proposal_id}:\")\n    print(f\"  Rule: {proposal.generated_rule.name}\")\n    print(f\"  Confidence: {proposal.generated_rule.confidence:.2%}\")\n    print(f\"  Savings: {proposal.roi_analysis.cost_reduction_absolute:.2f}\")\n    print(f\"  Status: {proposal.status.value}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#approving-or-rejecting","title":"Approving or Rejecting","text":"<pre><code># Approve a proposal\nmanager.approve(\n    proposal_id=proposal.proposal_id,\n    reviewer=\"analyst@example.com\",\n    notes=\"Pattern verified against historical data. Safe to proceed.\"\n)\n\n# Reject a proposal\nmanager.reject(\n    proposal_id=other_proposal.proposal_id,\n    reviewer=\"analyst@example.com\",\n    notes=\"Pattern too broad, high false positive risk in edge cases.\"\n)\n</code></pre>"},{"location":"tutorials/apls-learning/#ab-testing","title":"A/B Testing","text":"<pre><code># Start A/B testing\nmanager.start_testing(proposal.proposal_id)\n\n# Record test results over time\nmanager.record_test_results(\n    proposal_id=proposal.proposal_id,\n    results={\n        \"accuracy\": 0.94,\n        \"false_positive_rate\": 0.02,\n        \"samples_tested\": 1500,\n        \"test_duration_hours\": 48,\n    }\n)\n</code></pre>"},{"location":"tutorials/apls-learning/#activation-and-deprecation","title":"Activation and Deprecation","text":"<pre><code># Activate approved and tested rule\nmanager.activate(proposal.proposal_id)\n\n# Get all active rules\nactive_rules = manager.get_active_rules()\n\n# Later: deprecate if no longer needed\nmanager.deprecate(\n    proposal_id=proposal.proposal_id,\n    reason=\"Pattern no longer relevant after model update.\"\n)\n</code></pre>"},{"location":"tutorials/apls-learning/#export-and-import","title":"Export and Import","text":"<pre><code># Export all proposals\nmanager.export_proposals(Path(\"./proposals_backup.json\"))\n\n# Import proposals\nmanager.import_proposals(Path(\"./proposals_backup.json\"))\n</code></pre>"},{"location":"tutorials/apls-learning/#complete-apls-workflow","title":"Complete APLS Workflow","text":"<p>Here's a complete example bringing all components together:</p> <pre><code>import asyncio\nfrom pathlib import Path\nfrom datetime import datetime\nfrom rotalabs_cascade import (\n    CascadeEngine,\n    CascadeConfig,\n    StageConfig,\n    ExecutionContext,\n    StageResult,\n    PatternExtractor,\n    PatternConfig,\n    RuleGenerator,\n    CostAnalyzer,\n    ProposalManager,\n    EventWithContext,\n    UniversalEvent,\n    EventContext,\n    DomainType,\n    HistoricalContext,\n)\n\nasync def run_apls_workflow():\n    # 1. Set up the cascade engine (from previous tutorial)\n    engine = create_cascade_engine()\n\n    # 2. Set up APLS components\n    extractor = PatternExtractor(PatternConfig(\n        min_confidence=0.7,\n        min_samples_for_candidate=10,\n    ))\n\n    generator = RuleGenerator(min_confidence=0.7)\n\n    analyzer = CostAnalyzer()\n\n    manager = ProposalManager(storage_path=Path(\"./proposals\"))\n\n    # 3. Process events and learn patterns\n    print(\"Processing events and learning patterns...\")\n\n    for i in range(100):  # Simulate 100 events\n        event = generate_random_event(i)\n        result = await engine.execute(event)\n\n        # Learn from AI stage executions\n        if \"AI\" in result[\"stage_results\"]:\n            context = ExecutionContext(event)\n            ai_data = result[\"stage_results\"][\"AI\"]\n            stage_result = StageResult(\n                stage_name=\"AI\",\n                result=ai_data.get(\"result\"),\n                confidence=ai_data.get(\"confidence\"),\n                data=ai_data.get(\"data\", {}),\n                time_ms=ai_data.get(\"time_ms\", 0),\n            )\n            extractor.learn_from_failure(context, \"AI\", stage_result)\n\n    # 4. Get migration candidates\n    print(\"\\nFinding migration candidates...\")\n    candidates = extractor.get_migration_candidates(\n        min_confidence=0.8,\n        min_samples=5,\n    )\n    print(f\"Found {len(candidates)} candidates\")\n\n    # 5. Generate rules\n    print(\"\\nGenerating rules...\")\n    rules = generator.generate_batch(candidates)\n    print(f\"Generated {len(rules)} rules\")\n\n    # 6. Analyze ROI\n    print(\"\\nAnalyzing ROI...\")\n    roi_results = analyzer.analyze_all_candidates(\n        candidates=candidates,\n        target_stage=\"RULES\",\n        volume=10000,\n    )\n\n    savings = analyzer.get_total_potential_savings(roi_results)\n    print(f\"Total potential savings: {savings['total_absolute_savings']:.2f}\")\n    print(f\"Patterns to migrate: {savings['migrate_count']}\")\n\n    # 7. Create proposals for MIGRATE recommendations\n    print(\"\\nCreating proposals...\")\n    for rule, roi in zip(rules, roi_results):\n        if roi.recommendation == \"MIGRATE\":\n            proposal = manager.create_proposal(rule, roi)\n            print(f\"  Created: {proposal.proposal_id} - {rule.name}\")\n\n    # 8. Simulate human review\n    print(\"\\nPending proposals for review:\")\n    pending = manager.get_pending_proposals()\n    for p in pending:\n        print(f\"  {p.proposal_id}: {p.generated_rule.name}\")\n\n    print(\"\\nAPLS workflow complete!\")\n    return manager\n\n\ndef generate_random_event(seed: int) -&gt; EventWithContext:\n    \"\"\"Generate a random event for testing.\"\"\"\n    import random\n    random.seed(seed)\n\n    event = UniversalEvent(\n        id=f\"evt_{seed:04d}\",\n        domain=DomainType.FINANCE,\n        event_type=\"transaction\",\n        timestamp=datetime.now(),\n        primary_entity=f\"user_{random.randint(1, 100)}\",\n        secondary_entity=f\"merchant_{random.randint(1, 50)}\",\n        value=random.uniform(10, 10000),\n        unit=\"USD\",\n        domain_data={}\n    )\n\n    context = EventContext(\n        historical=HistoricalContext(\n            account_age_days=random.randint(1, 1000),\n            previous_events_count=random.randint(0, 500),\n            trust_score=random.uniform(0.2, 0.95),\n        )\n    )\n\n    return EventWithContext(event=event, context=context)\n\n\n# Run the workflow\nasyncio.run(run_apls_workflow())\n</code></pre>"},{"location":"tutorials/apls-learning/#best-practices","title":"Best Practices","text":""},{"location":"tutorials/apls-learning/#1-start-with-high-confidence-patterns","title":"1. Start with High-Confidence Patterns","text":"<p>Only migrate patterns with confidence &gt;= 0.8 to minimize false positives:</p> <pre><code>candidates = extractor.get_migration_candidates(\n    min_confidence=0.85,  # Start conservative\n    min_samples=20,       # Require more evidence\n)\n</code></pre>"},{"location":"tutorials/apls-learning/#2-use-ab-testing","title":"2. Use A/B Testing","text":"<p>Always test before full activation:</p> <pre><code># Test with 10% traffic first\nmanager.start_testing(proposal_id)\n# ... run tests ...\nmanager.record_test_results(proposal_id, {\n    \"traffic_percentage\": 10,\n    \"accuracy\": 0.96,\n    \"false_positive_rate\": 0.01,\n})\n</code></pre>"},{"location":"tutorials/apls-learning/#3-monitor-detection-rate-impact","title":"3. Monitor Detection Rate Impact","text":"<p>Watch for patterns that reduce detection effectiveness:</p> <pre><code>roi = analyzer.calculate_migration_roi(pattern, \"RULES\", volume=10000)\nif roi.detection_rate_change &lt; -0.05:  # &gt;5% detection rate drop\n    print(f\"Warning: Migration may reduce detection by {-roi.detection_rate_change:.1%}\")\n</code></pre>"},{"location":"tutorials/apls-learning/#4-set-up-automatic-pattern-expiration","title":"4. Set Up Automatic Pattern Expiration","text":"<p>Patterns should expire if not seen recently:</p> <pre><code>config = PatternConfig(\n    pattern_ttl_hours=168,  # 7 days\n)\n</code></pre>"},{"location":"tutorials/apls-learning/#5-export-rules-for-code-review","title":"5. Export Rules for Code Review","text":"<p>Generate YAML for human review:</p> <pre><code>yaml_output = generator.to_yaml(rules)\nwith open(\"proposed_rules.yaml\", \"w\") as f:\n    f.write(yaml_output)\n</code></pre>"},{"location":"tutorials/apls-learning/#summary","title":"Summary","text":"<p>APLS provides a complete framework for learning from expensive AI decisions and migrating patterns to cheaper rule-based stages:</p> <ol> <li>PatternExtractor learns from stage executions</li> <li>RuleGenerator converts patterns to rules</li> <li>CostAnalyzer calculates migration ROI</li> <li>ProposalManager handles human approval</li> </ol> <p>The result is continuous cost optimization while maintaining detection quality through human oversight and A/B testing.</p>"},{"location":"tutorials/basic-cascade/","title":"Building Your First Cascade","text":"<p>This tutorial walks you through building a complete 3-stage cascade system using rotalabs-cascade. You will learn how to define stages, register handlers, configure routing rules, and execute the cascade with different inputs.</p>"},{"location":"tutorials/basic-cascade/#what-were-building","title":"What We're Building","text":"<p>A typical cascade system routes events through progressively more sophisticated (and expensive) stages:</p> <ol> <li>RULES - Fast, deterministic rule checks (microseconds, nearly free)</li> <li>ML - Statistical/ML model inference (milliseconds, moderate cost)</li> <li>AI - LLM-based analysis (seconds, high cost)</li> </ol> <p>The goal is to resolve as many cases as possible in earlier stages, only escalating to more expensive stages when necessary.</p>"},{"location":"tutorials/basic-cascade/#prerequisites","title":"Prerequisites","text":"<p>Install rotalabs-cascade:</p> <pre><code>pip install rotalabs-cascade\n</code></pre>"},{"location":"tutorials/basic-cascade/#step-1-define-the-cascade-configuration","title":"Step 1: Define the Cascade Configuration","text":"<p>First, create the configuration that defines your stages and routing rules:</p> <pre><code>from rotalabs_cascade import (\n    CascadeConfig,\n    StageConfig,\n    RoutingRule,\n    RoutingAction,\n    Condition,\n    ConditionOperator,\n)\n\n# Define the three stages\nstages = {\n    \"RULES\": StageConfig(\n        name=\"RULES\",\n        enabled=True,\n        timeout_ms=1000,\n        routing_rules=[\n            # If rules stage has low confidence, enable ML\n            RoutingRule(\n                name=\"escalate_to_ml\",\n                type=\"routing\",\n                condition=Condition(\n                    field=\"stages.RULES.confidence\",\n                    operator=ConditionOperator.LT,\n                    value=0.9,\n                ),\n                action=RoutingAction(\n                    type=\"enable_stages\",\n                    stages=[\"ML\"],\n                ),\n                priority=10,\n            ),\n        ],\n    ),\n    \"ML\": StageConfig(\n        name=\"ML\",\n        enabled=False,  # Only enabled by RULES stage\n        timeout_ms=5000,\n        depends_on=[\"RULES\"],\n        routing_rules=[\n            # If ML has low confidence, enable AI\n            RoutingRule(\n                name=\"escalate_to_ai\",\n                type=\"routing\",\n                condition=Condition(\n                    field=\"stages.ML.confidence\",\n                    operator=ConditionOperator.LT,\n                    value=0.8,\n                ),\n                action=RoutingAction(\n                    type=\"enable_stages\",\n                    stages=[\"AI\"],\n                ),\n                priority=10,\n            ),\n        ],\n    ),\n    \"AI\": StageConfig(\n        name=\"AI\",\n        enabled=False,  # Only enabled by ML stage\n        timeout_ms=30000,\n        depends_on=[\"ML\"],\n    ),\n}\n\n# Create the cascade configuration\nconfig = CascadeConfig(\n    name=\"my_first_cascade\",\n    version=\"1.0.0\",\n    stages=stages,\n    execution_order=[\"RULES\", \"ML\", \"AI\"],\n    global_timeout_ms=60000,\n    max_parallel_stages=1,\n)\n</code></pre>"},{"location":"tutorials/basic-cascade/#understanding-the-configuration","title":"Understanding the Configuration","text":"<ul> <li>StageConfig: Defines each stage with its name, timeout, dependencies, and routing rules</li> <li>enabled: Stages start disabled and are enabled dynamically based on routing rules</li> <li>depends_on: Ensures stages execute in the correct order</li> <li>routing_rules: Define conditions that enable other stages or modify execution flow</li> <li>execution_order: The planned order of stage execution</li> </ul>"},{"location":"tutorials/basic-cascade/#step-2-create-the-cascade-engine","title":"Step 2: Create the Cascade Engine","text":"<p>Initialize the engine with your configuration:</p> <pre><code>from rotalabs_cascade import CascadeEngine\n\nengine = CascadeEngine(config)\n</code></pre>"},{"location":"tutorials/basic-cascade/#step-3-implement-stage-handlers","title":"Step 3: Implement Stage Handlers","text":"<p>Each stage needs an async handler function that processes the execution context and returns a result:</p> <pre><code>from rotalabs_cascade import ExecutionContext\nfrom typing import Dict, Any\n\nasync def rules_handler(context: ExecutionContext) -&gt; Dict[str, Any]:\n    \"\"\"Fast rule-based checks.\n\n    This handler runs deterministic rules to handle clear-cut cases.\n    \"\"\"\n    # Get input data\n    value = context.get(\"value\", 0)\n    domain = context.get(\"domain\", \"GENERIC\")\n    trust_score = context.get(\"trust_score\", 0.5)\n\n    # Apply simple rules\n    if value &lt; 10:\n        # Trivial value - auto-approve with high confidence\n        return {\n            \"result\": \"APPROVE\",\n            \"confidence\": 0.99,\n            \"data\": {\"reason\": \"below_threshold\"}\n        }\n\n    if trust_score &gt; 0.95:\n        # Highly trusted entity - auto-approve\n        return {\n            \"result\": \"APPROVE\",\n            \"confidence\": 0.95,\n            \"data\": {\"reason\": \"high_trust\"}\n        }\n\n    if value &gt; 10000:\n        # Very high value - needs deeper analysis\n        return {\n            \"result\": \"UNCERTAIN\",\n            \"confidence\": 0.3,\n            \"data\": {\"reason\": \"high_value_needs_review\"}\n        }\n\n    # Default: moderate confidence, may need ML\n    return {\n        \"result\": \"UNCERTAIN\",\n        \"confidence\": 0.7,\n        \"data\": {\"reason\": \"standard_check\"}\n    }\n\n\nasync def ml_handler(context: ExecutionContext) -&gt; Dict[str, Any]:\n    \"\"\"ML model inference.\n\n    This handler runs a trained model for pattern-based detection.\n    \"\"\"\n    # Get features for ML model\n    value = context.get(\"value\", 0)\n    account_age_days = context.get(\"account_age_days\", 0)\n    previous_events_count = context.get(\"historical.previous_events_count\", 0)\n\n    # Simulate ML model prediction\n    # In production, this would call your actual model\n    features = {\n        \"value_normalized\": min(value / 1000, 10),\n        \"account_maturity\": min(account_age_days / 365, 5),\n        \"activity_level\": min(previous_events_count / 100, 10),\n    }\n\n    # Simple heuristic (replace with actual model)\n    score = (\n        features[\"account_maturity\"] * 0.3 +\n        features[\"activity_level\"] * 0.3 +\n        (1 - features[\"value_normalized\"] / 10) * 0.4\n    )\n\n    if score &gt; 0.7:\n        return {\n            \"result\": \"APPROVE\",\n            \"confidence\": min(0.6 + score * 0.3, 0.95),\n            \"data\": {\"ml_score\": score, \"features\": features}\n        }\n    elif score &lt; 0.3:\n        return {\n            \"result\": \"REJECT\",\n            \"confidence\": min(0.6 + (1 - score) * 0.3, 0.95),\n            \"data\": {\"ml_score\": score, \"features\": features}\n        }\n    else:\n        # Uncertain - may need AI analysis\n        return {\n            \"result\": \"UNCERTAIN\",\n            \"confidence\": 0.5 + abs(score - 0.5) * 0.3,\n            \"data\": {\"ml_score\": score, \"features\": features}\n        }\n\n\nasync def ai_handler(context: ExecutionContext) -&gt; Dict[str, Any]:\n    \"\"\"LLM-based deep analysis.\n\n    This handler uses an LLM for nuanced reasoning on edge cases.\n    \"\"\"\n    # Get all available context\n    event_data = context.get(\"event\", {})\n    domain_data = event_data.get(\"domain_data\", {})\n\n    # Get previous stage results for context\n    rules_result = context.get_stage_result(\"RULES\")\n    ml_result = context.get_stage_result(\"ML\")\n\n    # Build reasoning context\n    reasoning_context = {\n        \"rules_result\": rules_result.to_dict() if rules_result else None,\n        \"ml_result\": ml_result.to_dict() if ml_result else None,\n        \"event_data\": event_data,\n    }\n\n    # Simulate LLM analysis\n    # In production, this would call your actual LLM\n    # For demo, we make a decision based on accumulated evidence\n\n    ml_score = 0.5\n    if ml_result and ml_result.data:\n        ml_score = ml_result.data.get(\"ml_score\", 0.5)\n\n    # AI makes final determination with explanation\n    if ml_score &gt; 0.5:\n        return {\n            \"result\": \"APPROVE\",\n            \"confidence\": 0.92,\n            \"data\": {\n                \"reasoning\": \"Based on account history and behavioral patterns, \"\n                            \"this activity appears consistent with normal usage.\",\n                \"factors\": [\"established_account\", \"consistent_behavior\", \"low_risk_profile\"]\n            }\n        }\n    else:\n        return {\n            \"result\": \"REJECT\",\n            \"confidence\": 0.88,\n            \"data\": {\n                \"reasoning\": \"Multiple risk indicators detected. Activity pattern \"\n                            \"deviates significantly from expected behavior.\",\n                \"factors\": [\"behavioral_anomaly\", \"elevated_risk\", \"insufficient_trust\"]\n            }\n        }\n</code></pre>"},{"location":"tutorials/basic-cascade/#step-4-register-handlers-with-the-engine","title":"Step 4: Register Handlers with the Engine","text":"<p>Connect your handlers to the engine:</p> <pre><code># Register each handler with its stage name\nengine.register_stage(\"RULES\", rules_handler)\nengine.register_stage(\"ML\", ml_handler)\nengine.register_stage(\"AI\", ai_handler)\n</code></pre>"},{"location":"tutorials/basic-cascade/#step-5-execute-the-cascade","title":"Step 5: Execute the Cascade","text":"<p>Now run the cascade with different inputs to see how routing works:</p> <pre><code>import asyncio\nfrom datetime import datetime\nfrom rotalabs_cascade import (\n    UniversalEvent,\n    EventContext,\n    EventWithContext,\n    DomainType,\n    HistoricalContext,\n)\n\nasync def main():\n    # Example 1: Simple case - resolved by RULES stage\n    print(\"=\" * 60)\n    print(\"Example 1: Low value transaction (should resolve in RULES)\")\n    print(\"=\" * 60)\n\n    event1 = UniversalEvent(\n        id=\"evt_001\",\n        domain=DomainType.FINANCE,\n        event_type=\"transaction\",\n        timestamp=datetime.now(),\n        primary_entity=\"user_123\",\n        secondary_entity=\"merchant_456\",\n        value=5.00,  # Small value\n        unit=\"USD\",\n        domain_data={}\n    )\n\n    context1 = EventContext(\n        historical=HistoricalContext(trust_score=0.8)\n    )\n\n    result1 = await engine.execute(EventWithContext(event=event1, context=context1))\n    print(f\"Stages executed: {result1['stages_executed']}\")\n    print(f\"Execution time: {result1['execution_time_ms']:.2f}ms\")\n    print(f\"Stage results: {list(result1['stage_results'].keys())}\")\n    print()\n\n    # Example 2: Medium case - escalates to ML\n    print(\"=\" * 60)\n    print(\"Example 2: Medium value, new account (should escalate to ML)\")\n    print(\"=\" * 60)\n\n    event2 = UniversalEvent(\n        id=\"evt_002\",\n        domain=DomainType.FINANCE,\n        event_type=\"transaction\",\n        timestamp=datetime.now(),\n        primary_entity=\"user_789\",\n        secondary_entity=\"merchant_012\",\n        value=500.00,  # Medium value\n        unit=\"USD\",\n        domain_data={}\n    )\n\n    context2 = EventContext(\n        historical=HistoricalContext(\n            trust_score=0.6,\n            account_age_days=30,\n            previous_events_count=10\n        )\n    )\n\n    result2 = await engine.execute(EventWithContext(event=event2, context=context2))\n    print(f\"Stages executed: {result2['stages_executed']}\")\n    print(f\"Execution time: {result2['execution_time_ms']:.2f}ms\")\n    print(f\"Stage results: {list(result2['stage_results'].keys())}\")\n    print()\n\n    # Example 3: Complex case - escalates all the way to AI\n    print(\"=\" * 60)\n    print(\"Example 3: High value, risky profile (should escalate to AI)\")\n    print(\"=\" * 60)\n\n    event3 = UniversalEvent(\n        id=\"evt_003\",\n        domain=DomainType.FINANCE,\n        event_type=\"transaction\",\n        timestamp=datetime.now(),\n        primary_entity=\"user_999\",\n        secondary_entity=\"merchant_777\",\n        value=15000.00,  # High value\n        unit=\"USD\",\n        domain_data={}\n    )\n\n    context3 = EventContext(\n        historical=HistoricalContext(\n            trust_score=0.3,\n            account_age_days=7,  # Very new account\n            previous_events_count=2\n        )\n    )\n\n    result3 = await engine.execute(EventWithContext(event=event3, context=context3))\n    print(f\"Stages executed: {result3['stages_executed']}\")\n    print(f\"Execution time: {result3['execution_time_ms']:.2f}ms\")\n    print(f\"Stage results: {list(result3['stage_results'].keys())}\")\n\n    # Print detailed AI reasoning if available\n    if \"AI\" in result3[\"stage_results\"]:\n        ai_result = result3[\"stage_results\"][\"AI\"]\n        print(f\"\\nAI Decision: {ai_result.get('result')}\")\n        print(f\"AI Confidence: {ai_result.get('confidence')}\")\n        if ai_result.get(\"data\", {}).get(\"reasoning\"):\n            print(f\"AI Reasoning: {ai_result['data']['reasoning']}\")\n\n# Run the cascade\nasyncio.run(main())\n</code></pre>"},{"location":"tutorials/basic-cascade/#expected-output","title":"Expected Output","text":"<pre><code>============================================================\nExample 1: Low value transaction (should resolve in RULES)\n============================================================\nStages executed: 1\nExecution time: 0.15ms\nStage results: ['RULES']\n\n============================================================\nExample 2: Medium value, new account (should escalate to ML)\n============================================================\nStages executed: 2\nExecution time: 0.45ms\nStage results: ['RULES', 'ML']\n\n============================================================\nExample 3: High value, risky profile (should escalate to AI)\n============================================================\nStages executed: 3\nExecution time: 1.23ms\nStage results: ['RULES', 'ML', 'AI']\n\nAI Decision: REJECT\nAI Confidence: 0.88\nAI Reasoning: Multiple risk indicators detected. Activity pattern deviates significantly from expected behavior.\n</code></pre>"},{"location":"tutorials/basic-cascade/#interpreting-the-results","title":"Interpreting the Results","text":"<p>The execution result dictionary contains:</p> <pre><code>{\n    \"success\": True,                    # Whether execution completed without errors\n    \"execution_time_ms\": 1.23,          # Total execution time\n    \"stages_executed\": 3,               # Number of stages that ran\n    \"stage_results\": {\n        \"RULES\": {\n            \"stage_name\": \"RULES\",\n            \"result\": \"UNCERTAIN\",\n            \"confidence\": 0.3,\n            \"time_ms\": 0.12,\n            \"data\": {\"reason\": \"high_value_needs_review\"}\n        },\n        \"ML\": {\n            \"stage_name\": \"ML\",\n            \"result\": \"UNCERTAIN\",\n            \"confidence\": 0.55,\n            \"time_ms\": 0.31,\n            \"data\": {\"ml_score\": 0.45, \"features\": {...}}\n        },\n        \"AI\": {\n            \"stage_name\": \"AI\",\n            \"result\": \"REJECT\",\n            \"confidence\": 0.88,\n            \"time_ms\": 0.80,\n            \"data\": {\"reasoning\": \"...\", \"factors\": [...]}\n        }\n    },\n    \"timeline\": [...],                   # Execution timeline events\n    \"routing_decisions\": [...]           # Routing decisions made\n}\n</code></pre>"},{"location":"tutorials/basic-cascade/#key-fields","title":"Key Fields","text":"<ul> <li>stage_results: Contains the output from each executed stage</li> <li>confidence: The stage's confidence in its decision (0-1)</li> <li>data: Stage-specific data (reasoning, features, etc.)</li> <li>routing_decisions: Shows which stages were enabled and why</li> </ul>"},{"location":"tutorials/basic-cascade/#adding-global-termination-conditions","title":"Adding Global Termination Conditions","text":"<p>You can add conditions that terminate the cascade early:</p> <pre><code>config = CascadeConfig(\n    name=\"my_cascade\",\n    version=\"1.0.0\",\n    stages=stages,\n    execution_order=[\"RULES\", \"ML\", \"AI\"],\n    global_termination_conditions=[\n        # Terminate if any stage returns REJECT with high confidence\n        Condition(\n            operator=ConditionOperator.AND,\n            conditions=[\n                Condition(\n                    field=\"stages.RULES.result\",\n                    operator=ConditionOperator.EQ,\n                    value=\"REJECT\",\n                ),\n                Condition(\n                    field=\"stages.RULES.confidence\",\n                    operator=ConditionOperator.GE,\n                    value=0.95,\n                ),\n            ]\n        ),\n    ],\n    global_timeout_ms=60000,\n)\n</code></pre>"},{"location":"tutorials/basic-cascade/#using-flat-dictionary-input","title":"Using Flat Dictionary Input","text":"<p>For backward compatibility, you can also pass a flat dictionary instead of <code>EventWithContext</code>:</p> <pre><code>result = await engine.execute({\n    \"value\": 500.00,\n    \"trust_score\": 0.6,\n    \"account_age_days\": 30,\n    \"previous_events_count\": 10,\n    \"domain\": \"FINANCE\",\n})\n</code></pre>"},{"location":"tutorials/basic-cascade/#summary","title":"Summary","text":"<p>You have now built a complete 3-stage cascade that:</p> <ol> <li>Starts with fast, cheap rule-based checks</li> <li>Escalates uncertain cases to ML inference</li> <li>Further escalates edge cases to AI analysis</li> <li>Routes dynamically based on confidence scores</li> <li>Tracks execution timeline and routing decisions</li> </ol> <p>This pattern efficiently handles the 80/20 distribution where most cases can be resolved quickly, while ensuring complex cases get the analysis they need.</p>"},{"location":"tutorials/basic-cascade/#next-steps","title":"Next Steps","text":"<ul> <li>Learn about APLS (Adaptive Pattern Learning System) to optimize costs</li> <li>Explore Event + Context Pattern for domain-agnostic design</li> <li>Configure caching and parallel execution for production deployments</li> </ul>"}]}